import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{o as e,c as n,f as i}from"./app-21ce620e.js";const s={},t=i(`<h2 id="rabbitmq集群的两种模式" tabindex="-1"><a class="header-anchor" href="#rabbitmq集群的两种模式" aria-hidden="true">#</a> RabbitMQ集群的两种模式</h2><h3 id="普通集群" tabindex="-1"><a class="header-anchor" href="#普通集群" aria-hidden="true">#</a> 普通集群</h3><p>普通集群模式，就是将 RabbitMQ 部署到多台服务器上，每个服务器启动一个 RabbitMQ 实例，多个实例之间进行消息通信。</p><p>此时我们创建的队列 Queue，它的元数据（主要就是 Queue 的一些配置信息）会在所有的 RabbitMQ 实例中进行同步，但是队列中的消息只会存在于一个 RabbitMQ 实例上，而不会同步到其他队列。</p><p>当我们消费消息的时候，如果连接到了另外一个实例，那么那个实例会通过元数据定位到 Queue 所在的位置，然后访问 Queue 所在的实例，拉取数据过来发送给消费者。</p><p>这种集群可以提高 RabbitMQ 的消息吞吐能力，但是无法保证高可用，因为一旦一个 RabbitMQ 实例挂了，消息就没法访问了，如果消息队列做了持久化，那么等 RabbitMQ 实例恢复后，就可以继续访问了；如果消息队列没做持久化，那么消息就丢了。</p><p>大致的流程图如下图：</p><figure><img src="https://img.jssjqd.cn/202211080149876.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="镜像集群" tabindex="-1"><a class="header-anchor" href="#镜像集群" aria-hidden="true">#</a> 镜像集群</h3><p>它和普通集群最大的区别在于Queue数据和原数据不再是单独存储在一台机器上，而是同时存储在多台机器上。也就是说每个RabbitMQ实例都有一份镜像数据（副本数据）。每次写入消息的时候都会自动把数据同步到多台实例上去，这样一旦其中一台机器发生故障，其他机器还有一份副本数据可以继续提供服务，也就实现了高可用。</p><p>大致流程图如下图：</p><figure><img src="https://img.jssjqd.cn/202211080149140.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="节点类型" tabindex="-1"><a class="header-anchor" href="#节点类型" aria-hidden="true">#</a> 节点类型</h2><p>RabbitMQ 中的节点类型有两种：</p><ul><li>RAM node：内存节点将所有的队列、交换机、绑定、用户、权限和 vhost 的元数据定义存储在内存中，好处是可以使得交换机和队列声明等操作速度更快。</li><li>Disk node：将元数据存储在磁盘中，单节点系统只允许磁盘类型的节点，防止重启 RabbitMQ 的时候，丢失系统的配置信息</li></ul><p>RabbitMQ 要求在集群中至少有一个磁盘节点，所有其他节点可以是内存节点，当节点加入或者离开集群时，必须要将该变更通知到至少一个磁盘节点。如果集群中唯一的一个磁盘节点崩溃的话，集群仍然可以保持运行，但是无法进行其他操作（增删改查），直到节点恢复。为了确保集群信息的可靠性，或者在不确定使用磁盘节点还是内存节点的时候，建议直接用磁盘节点。</p><h2 id="rabbitmq集群搭建" tabindex="-1"><a class="header-anchor" href="#rabbitmq集群搭建" aria-hidden="true">#</a> RabbitMQ集群搭建</h2><h3 id="普通集群-1" tabindex="-1"><a class="header-anchor" href="#普通集群-1" aria-hidden="true">#</a> 普通集群</h3><h4 id="预备知识" tabindex="-1"><a class="header-anchor" href="#预备知识" aria-hidden="true">#</a> <strong>预备知识</strong></h4><p>大致的结构了解了，接下来我们就把集群给搭建起来。先从普通集群开始，我们就使用 docker 来搭建。</p><p>搭建之前，有两个预备知识需要大家了解：</p><ul><li>搭建集群时，节点中的 Erlang Cookie 值要一致，默认情况下，文件在 /var/lib/rabbitmq/.erlang.cookie，我们在用 docker 创建 RabbitMQ 容器时，可以为之设置相应的 Cookie 值。</li><li>RabbitMQ 是通过主机名来连接服务，必须保证各个主机名之间可以 ping 通。可以通过编辑 /etc/hosts 来手工添加主机名和 IP 对应关系。如果主机名 ping 不通，RabbitMQ 服务启动会失败（如果我们是在不同的服务器上搭建 RabbitMQ 集群，大家需要注意这一点，接下来的 2.2 小结，我们将通过 Docker 的容器连接 link 来实现容器之间的访问，略有不同）。</li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>docker run -d -p 15672:15672 -p 5672:5672 --name rabbit rabbitmq

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="开始搭建" tabindex="-1"><a class="header-anchor" href="#开始搭建" aria-hidden="true">#</a> 开始搭建</h4><p>执行如下命令创建三个 RabbitMQ 容器：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--hostname</span> rabbit01 <span class="token parameter variable">--name</span> mq01 <span class="token parameter variable">-p</span> <span class="token number">5671</span>:5672 <span class="token parameter variable">-p</span> <span class="token number">15671</span>:15672 <span class="token parameter variable">-e</span> <span class="token assign-left variable">RABBITMQ_ERLANG_COOKIE</span><span class="token operator">=</span><span class="token string">&quot;javaboy_rabbitmq_cookie&quot;</span> rabbitmq:3-management

<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--hostname</span> rabbit02 <span class="token parameter variable">--name</span> mq02 <span class="token parameter variable">--link</span> mq01:mylink01 <span class="token parameter variable">-p</span> <span class="token number">5672</span>:5672 <span class="token parameter variable">-p</span> <span class="token number">15672</span>:15672 <span class="token parameter variable">-e</span> <span class="token assign-left variable">RABBITMQ_ERLANG_COOKIE</span><span class="token operator">=</span><span class="token string">&quot;javaboy_rabbitmq_cookie&quot;</span> rabbitmq:3-management

<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">--hostname</span> rabbit03 <span class="token parameter variable">--name</span> mq03 <span class="token parameter variable">--link</span> mq01:mylink02 <span class="token parameter variable">--link</span> mq02:mylink03 <span class="token parameter variable">-p</span> <span class="token number">5673</span>:5672 <span class="token parameter variable">-p</span> <span class="token number">15673</span>:15672 <span class="token parameter variable">-e</span> <span class="token assign-left variable">RABBITMQ_ERLANG_COOKIE</span><span class="token operator">=</span><span class="token string">&quot;javaboy_rabbitmq_cookie&quot;</span> rabbitmq:3-management
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>运行结果如下：</p><figure><img src="https://img.jssjqd.cn/202211080149779.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>三个节点现在就启动好了，注意在mq02和mq03中，分别使用了--link参数来实现容器连接。另外还需要注意，mq03容器中要既能够连接mq01也能够连接mq02。</p><p>接下来进入到 mq02 容器中，首先查看一下 hosts 文件，可以看到我们配置的容器连接已经生效了： <img src="https://img.jssjqd.cn/202211080149853.png" alt="" loading="lazy"></p><p>将来在mq02容器中，就可以通过mylink01或者rabbit01访问到mq01容器了。</p><p>接下来我们开始集群的配置。</p><p>分别执行如下命令将 mq02 容器加入集群中：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>rabbitmqctl stop_app
rabbitmqctl join_cluster rabbit@rabbit01
rabbitmqctl start_app
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来输入如下命令我们可以查看集群的状态：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>rabbitmqctl cluster_status
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://img.jssjqd.cn/202211080149513.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>可以看到，集群中已经有两个节点了。</p><p>接下来通过相同的方式将 mq03 也加入到集群中：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>rabbitmqctl stop_app

rabbitmqctl join_cluster rabbit@rabbit01

rabbitmqctl start_app
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://img.jssjqd.cn/202211080149926.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>接下来，我们可以查看集群信息：</p><figure><img src="https://img.jssjqd.cn/202211080149829.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>可以看到，此时集群中已经有三个节点了。</p><p>其实，这个时候，我们也可以通过网页来查看集群信息，在三个 RabbitMQ 实例的 Web 端首页，都可以看到如下内容：</p><figure><img src="https://img.jssjqd.cn/202211080149079.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="代码测试" tabindex="-1"><a class="header-anchor" href="#代码测试" aria-hidden="true">#</a> 代码测试</h4><p>接下来我们来简单测试一下这个集群。</p><p>我们创建一个名为 mq_cluster_demo 的父工程，然后在其中创建两个子工程。</p><p>第一个子工程名为 provider，是一个消息生产者，创建时引入 Web 和 RabbitMQ 依赖，如下：</p><figure><img src="https://img.jssjqd.cn/202211080149996.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>然后配置 applicaiton.properties，内容如下（注意集群配置）：</p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token key attr-name">spring.rabbitmq.addresses</span><span class="token punctuation">=</span><span class="token value attr-value">localhost:5671,localhost:5672,localhost:5673</span>
<span class="token key attr-name">spring.rabbitmq.username</span><span class="token punctuation">=</span><span class="token value attr-value">guest</span>
<span class="token key attr-name">spring.rabbitmq.password</span><span class="token punctuation">=</span><span class="token value attr-value">guest</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接下来提供一个简单的队列，如下：</p><div class="language-JAVA line-numbers-mode" data-ext="JAVA"><pre class="language-JAVA"><code>@Configuration
public class RabbitConfig {
    public static final String MY_QUEUE_NAME = &quot;my_queue_name&quot;;
    public static final String MY_EXCHANGE_NAME = &quot;my_exchange_name&quot;;
    public static final String MY_ROUTING_KEY = &quot;my_queue_name&quot;;

    @Bean
    Queue queue() {
        return new Queue(MY_QUEUE_NAME, true, false, false);
    }

    @Bean
    DirectExchange directExchange() {
        return new DirectExchange(MY_EXCHANGE_NAME, true, false);
    }

    @Bean
    Binding binding() {
        return BindingBuilder.bind(queue())
                .to(directExchange())
                .with(MY_ROUTING_KEY);
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个没啥好说的，都是基本内容，接下来我们在单元测试中进行消息发送测试：</p><div class="language-JAVA line-numbers-mode" data-ext="JAVA"><pre class="language-JAVA"><code>@SpringBootTest
class ProviderApplicationTests {

    @Autowired
    RabbitTemplate rabbitTemplate;

    @Test
    void contextLoads() {
        rabbitTemplate.convertAndSend(null, RabbitConfig.MY_QUEUE_NAME, &quot;hello 江南一点雨&quot;);
    }

}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这条消息发送成功之后，在 RabbitMQ 的 Web 管理端，我们会看到三个 RabbitMQ 实例上都会显示有一条消息，但是实际上消息本身只存在于一个 RabbitMQ 实例。</p><p>接下来我们再创建一个消息消费者，消息消费者的依赖以及配置和消息生产者都是一模一样，我就不重复了，消息消费者中增加一个消息接收器：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>@Component
public class MsgReceiver {

    @RabbitListener(queues = RabbitConfig.MY_QUEUE_NAME)
    public void handleMsg(String msg) {
        System.out.println(&quot;msg = &quot; + msg);
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当消息消费者启动成功后，这个方法中只收到一条消息，进一步验证了我们搭建的 RabbitMQ 集群是没问题的。</p><h4 id="反向测试" tabindex="-1"><a class="header-anchor" href="#反向测试" aria-hidden="true">#</a> 反向测试</h4><p>接下来松哥再举两个反例，以证明消息并没有同步到其他 RabbitMQ 实例。</p><p>确保三个 RabbitMQ 实例都是启动状态，关闭掉 Consumer，然后通过 provider 发送一条消息，发送成功之后，关闭 mq01 实例，然后启动 Consumer 实例，此时 Consumer 实例并不会消费消息，反而会报错说 mq01 实例连接不上，这个例子就可以说明消息在 mq01 上，并没有同步到另外两个 MQ 上。相反，如果 provider 发送消息成功之后，我们没有关闭 mq01 实例而是关闭了 mq02 实例，那么你就会发现消息的消费不受影响。</p><h3 id="镜像集群-1" tabindex="-1"><a class="header-anchor" href="#镜像集群-1" aria-hidden="true">#</a> 镜像集群</h3><p>所谓的镜像集群模式并不需要额外搭建，只需要我们将队列配置为镜像队列即可。</p><p>这个配置可以通过网页配置，也可以通过命令行配置，我们分别来看。</p><h4 id="网页配置镜像队列" tabindex="-1"><a class="header-anchor" href="#网页配置镜像队列" aria-hidden="true">#</a> 网页配置镜像队列</h4><p>先来看看网页上如何配置镜像队列。</p><p>点击 Admin 选项卡，然后点击右边的 Policies，再点击 Add/update a policy，如下图： <img src="https://img.jssjqd.cn/202211080149005.png" alt="" loading="lazy"></p><p>接下来添加一个策略，如下图：</p><figure><img src="https://img.jssjqd.cn/202211080149380.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>各参数含义如下：</p><ul><li>Name: policy 的名称。</li><li>Pattern: queue 的匹配模式 (正则表达式)。</li><li>Definition：镜像定义，主要有三个参数：ha-mode, ha-params, ha-sync-mode。 <ul><li>ha-mode：指明镜像队列的模式，有效值为 all、exactly、nodes。其中 all 表示在集群中所有的节点上进行镜像（默认即此）；exactly 表示在指定个数的节点上进行镜像，节点的个数由 ha-params 指定；nodes 表示在指定的节点上进行镜像，节点名称通过 ha-params 指定。</li><li>ha-params：ha-mode 模式需要用到的参数。</li><li>ha-sync-mode：进行队列中消息的同步方式，有效值为 automatic 和 manual。</li><li>priority 为可选参数，表示 policy 的优先级。</li></ul></li></ul><p>配置完成后，点击下面的 add/update policy 按钮，完成策略的添加，如下：</p><p>添加完成后，我们可以进行一个简单的测试。</p><p>首先确认三个 RabbitMQ 都启动了，然后用上面的 provider 向消息队列发送一条消息。</p><p>发完之后关闭 mq01 实例。</p><p>接下来启动 consumer，此时发现 consumer 可以完成消息的消费（注意和前面的反向测试区分），这就说明镜像队列已经搭建成功了。</p><h4 id="命令行配置镜像队列" tabindex="-1"><a class="header-anchor" href="#命令行配置镜像队列" aria-hidden="true">#</a> 命令行配置镜像队列</h4><p>命令行的配置格式如下：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>rabbitmqctl set_policy <span class="token punctuation">[</span>-p vhost<span class="token punctuation">]</span> <span class="token punctuation">[</span>--priority priority<span class="token punctuation">]</span> <span class="token punctuation">[</span>--apply-to apply-to<span class="token punctuation">]</span> <span class="token punctuation">{</span>name<span class="token punctuation">}</span> <span class="token punctuation">{</span>pattern<span class="token punctuation">}</span> <span class="token punctuation">{</span>definition<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>举一个简单的配置案例：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>rabbitmqctl set_policy <span class="token parameter variable">-p</span> / --apply-to queues my_queue_mirror <span class="token string">&quot;^&quot;</span> <span class="token string">&#39;{&quot;ha-mode&quot;:&quot;all&quot;,&quot;ha-sync-mode&quot;:&quot;automatic&quot;}&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,84),l=[t];function r(p,d){return e(),n("div",null,l)}const u=a(s,[["render",r],["__file","index.html.vue"]]);export{u as default};
