const e=JSON.parse('{"key":"v-487e9ee8","path":"/pages/ae15fa/","title":"RabbitMQ高级使用场景","lang":"zh-CN","frontmatter":{"title":"RabbitMQ高级使用场景","date":"2022-12-04T01:48:42.000Z","permalink":"/pages/ae15fa/","author":{"name":"江"},"category":["消息队列","RabbitMQ"],"description":"​\\tRabbitMQ是一个功能非常全面的MQ产品，本身是基于AMQP这样一个非常严格的开放式协议构建的，又历经了非常多企业的业务场景验证，所以，RabbitMQ的强大，代表的是一个生态，而不仅仅是一个MQ产品。永远不要觉得之前在公司用过或者学会了一些常用的编程框架，就能够彻底掌握好RabbitMQ。这一章节，主要是结合一些应用场景，对上一章节一大堆的编程模型进行查漏补缺。当然，这里的一些使用经验，也不可能完全囊括RabbitMQ的所有问题，还有很多问题，需要自行理解和总结。 Headers路由 在官网的体验示例中，还有一种路由策略并没有提及，那就是Headers路由。其实官网之所以没有过多介绍，就是因为这种策略在实际中用得比较少，但是在某些比较特殊的业务场景，还是挺好用的。","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/pages/ae15fa/"}],["meta",{"property":"og:site_name","content":"学习笔记"}],["meta",{"property":"og:title","content":"RabbitMQ高级使用场景"}],["meta",{"property":"og:description","content":"​\\tRabbitMQ是一个功能非常全面的MQ产品，本身是基于AMQP这样一个非常严格的开放式协议构建的，又历经了非常多企业的业务场景验证，所以，RabbitMQ的强大，代表的是一个生态，而不仅仅是一个MQ产品。永远不要觉得之前在公司用过或者学会了一些常用的编程框架，就能够彻底掌握好RabbitMQ。这一章节，主要是结合一些应用场景，对上一章节一大堆的编程模型进行查漏补缺。当然，这里的一些使用经验，也不可能完全囊括RabbitMQ的所有问题，还有很多问题，需要自行理解和总结。 Headers路由 在官网的体验示例中，还有一种路由策略并没有提及，那就是Headers路由。其实官网之所以没有过多介绍，就是因为这种策略在实际中用得比较少，但是在某些比较特殊的业务场景，还是挺好用的。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-08-01T18:24:48.000Z"}],["meta",{"property":"article:author","content":"江"}],["meta",{"property":"article:published_time","content":"2022-12-04T01:48:42.000Z"}],["meta",{"property":"article:modified_time","content":"2023-08-01T18:24:48.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"RabbitMQ高级使用场景\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-12-04T01:48:42.000Z\\",\\"dateModified\\":\\"2023-08-01T18:24:48.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"江\\"}]}"]]},"headers":[{"level":2,"title":"Headers路由","slug":"headers路由","link":"#headers路由","children":[]},{"level":2,"title":"分组消费模式","slug":"分组消费模式","link":"#分组消费模式","children":[{"level":3,"title":"什么是分组消费模式","slug":"什么是分组消费模式","link":"#什么是分组消费模式","children":[]},{"level":3,"title":"实例测试","slug":"实例测试","link":"#实例测试","children":[]},{"level":3,"title":"实现原理","slug":"实现原理","link":"#实现原理","children":[]}]},{"level":2,"title":"死信队列","slug":"死信队列","link":"#死信队列","children":[{"level":3,"title":"何时会产生死信","slug":"何时会产生死信","link":"#何时会产生死信","children":[]},{"level":3,"title":"死信队列的配置方式","slug":"死信队列的配置方式","link":"#死信队列的配置方式","children":[]},{"level":3,"title":"关于参数x-dead-letter-routing-key","slug":"关于参数x-dead-letter-routing-key","link":"#关于参数x-dead-letter-routing-key","children":[]},{"level":3,"title":"如何确定一个消息是不是死信","slug":"如何确定一个消息是不是死信","link":"#如何确定一个消息是不是死信","children":[]},{"level":3,"title":"死信队列如何消费","slug":"死信队列如何消费","link":"#死信队列如何消费","children":[]}]},{"level":2,"title":"消费优先级与流量控制","slug":"消费优先级与流量控制","link":"#消费优先级与流量控制","children":[]},{"level":2,"title":"远程数据分发插件-Federation Plugin","slug":"远程数据分发插件-federation-plugin","link":"#远程数据分发插件-federation-plugin","children":[{"level":3,"title":"启动插件","slug":"启动插件","link":"#启动插件","children":[]},{"level":3,"title":"配置Upstream","slug":"配置upstream","link":"#配置upstream","children":[]},{"level":3,"title":"配置Federation策略","slug":"配置federation策略","link":"#配置federation策略","children":[]},{"level":3,"title":"测试","slug":"测试","link":"#测试","children":[]}]},{"level":2,"title":"懒队列Lazy Queue","slug":"懒队列lazy-queue","link":"#懒队列lazy-queue","children":[]},{"level":2,"title":"消息分片存储插件-Sharding Plugin","slug":"消息分片存储插件-sharding-plugin","link":"#消息分片存储插件-sharding-plugin","children":[{"level":3,"title":"安装Sharding插件","slug":"安装sharding插件","link":"#安装sharding插件","children":[]},{"level":3,"title":"配置Sharding策略","slug":"配置sharding策略","link":"#配置sharding策略","children":[]},{"level":3,"title":"新增带Sharding的Exchange交换机","slug":"新增带sharding的exchange交换机","link":"#新增带sharding的exchange交换机","children":[]},{"level":3,"title":"往分片交换机上发送消息","slug":"往分片交换机上发送消息","link":"#往分片交换机上发送消息","children":[]},{"level":3,"title":"消费分片交换机上的消息","slug":"消费分片交换机上的消息","link":"#消费分片交换机上的消息","children":[]},{"level":3,"title":"注意事项","slug":"注意事项","link":"#注意事项","children":[]}]}],"git":{"createdTime":1690914288000,"updatedTime":1690914288000,"contributors":[{"name":"jiangqingdong","email":"thejqd@gmail.com","commits":1}]},"readingTime":{"minutes":22.88,"words":6865},"filePathRelative":"30.分布式框架/05.消息队列/00.RabbitMQ/20.RabbitMQ高级使用场景.md","localizedDate":"2022年12月4日","excerpt":"<p>​\\tRabbitMQ是一个功能非常全面的MQ产品，本身是基于AMQP这样一个非常严格的开放式协议构建的，又历经了非常多企业的业务场景验证，所以，RabbitMQ的强大，代表的是一个生态，而不仅仅是一个MQ产品。永远不要觉得之前在公司用过或者学会了一些常用的编程框架，就能够彻底掌握好RabbitMQ。这一章节，主要是结合一些应用场景，对上一章节一大堆的编程模型进行查漏补缺。当然，这里的一些使用经验，也不可能完全囊括RabbitMQ的所有问题，还有很多问题，需要自行理解和总结。</p>\\n<h2> Headers路由</h2>\\n<p>在官网的体验示例中，还有一种路由策略并没有提及，那就是Headers路由。其实官网之所以没有过多介绍，就是因为这种策略在实际中用得比较少，但是在某些比较特殊的业务场景，还是挺好用的。</p>","autoDesc":true}');export{e as data};
