import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{r as t,o,c as p,a as n,b as s,e,f as l}from"./app-c8395efa.js";const r={},c=l(`<h2 id="es集群架构" tabindex="-1"><a class="header-anchor" href="#es集群架构" aria-hidden="true">#</a> ES集群架构</h2><p>分布式系统的可用性与扩展性</p><ul><li><p>高可用性</p></li><li><ul><li>服务可用性-允许有节点停止服务</li><li>数据可用性-部分节点丢失，不会丢失数据</li></ul></li><li><p>可扩展性</p></li><li><ul><li>请求量提升/数据的不断增长(将数据分布到所有节点上)</li></ul></li></ul><p>ES集群架构的优势：</p><ul><li>提高系统的可用性，部分节点停止服务，整个集群的服务不受影响</li><li>存储的水平扩容</li></ul><p>​ <img src="https://note.youdao.com/yws/public/resource/16ca3fcfcdda46a976cfd978e20df4be/xmlnote/497DEBC014604E3A8AE5FED252F844F8/48958" alt="0" loading="lazy"></p><h2 id="核心概念" tabindex="-1"><a class="header-anchor" href="#核心概念" aria-hidden="true">#</a> 核心概念</h2><h3 id="集群" tabindex="-1"><a class="header-anchor" href="#集群" aria-hidden="true">#</a> 集群</h3><ul><li>一个集群可以有一个或者多个节点</li><li>不同的集群通过不同的名字来区分，默认名字“elasticsearch“</li><li>通过配置文件修改，或者在命令行中 -E cluster.name=es-cluster进行设定</li></ul><h3 id="节点" tabindex="-1"><a class="header-anchor" href="#节点" aria-hidden="true">#</a> 节点</h3><ul><li><p>节点是一个Elasticsearch的实例</p></li><li><ul><li>本质上就是一个JAVA进程</li><li>一台机器上可以运行多个Elasticsearch进程，但是生产环境一般建议一台机器上只运</li></ul></li></ul><p>行一个Elasticsearch实例</p><ul><li>每一个节点都有名字，通过配置文件配置，或者启动时候 -E node.name=node1指定</li><li>每一个节点在启动之后，会分配一个UID，保存在data目录下</li></ul><p><strong>节点类型</strong></p><ul><li>Master Node：主节点</li><li>Master eligible nodes：可以参与选举的合格节点</li><li>Data Node：数据节点</li><li>Coordinating Node：协调节点</li><li>其他节点</li></ul><figure><img src="https://img.jssjqd.cn//202305022150908.png" alt="image-20230502215019978" tabindex="0" loading="lazy"><figcaption>image-20230502215019978</figcaption></figure><p><strong>Master eligible nodes和Master Node</strong></p><ul><li><p>每个节点启动后，默认就是一个Master eligible节点</p></li><li><ul><li>可以设置 node.master: false禁止</li></ul></li><li><p>Master-eligible节点可以参加选主流程，成为Master节点</p></li><li><p>当第一个节点启动时候，它会将自己选举成Master节点</p></li><li><p>每个节点上都保存了集群的状态，只有Master节点才能修改集群的状态信息</p></li><li><ul><li><p>集群状态(Cluster State) ，维护了一个集群中，必要的信息</p></li><li><ul><li>所有的节点信息</li><li>所有的索引和其相关的Mapping与Setting信息</li><li>分片的路由信息</li></ul></li></ul></li></ul><p><strong>Master Node的职责</strong></p><ul><li>处理创建，删除索引等请求，负责索引的创建与删除</li><li>决定分片被分配到哪个节点</li><li>维护并且更新Cluster State</li></ul><p><strong>Master Node的最佳实践</strong></p><ul><li>Master节点非常重要，在部署上需要考虑解决单点的问题</li><li>为一个集群设置多个Master节点，每个节点只承担Master 的单一角色</li></ul><p><strong>选主的过程</strong></p><ul><li>互相Ping对方，Node ld 低的会成为被选举的节点</li><li>其他节点会加入集群，但是不承担Master节点的角色。一旦发现被选中的主节点丢失，就会选举出新的Master节点</li></ul><p><strong>Data Node &amp; Coordinating Node</strong></p><ul><li><p>Data Node</p></li><li><ul><li>可以保存数据的节点，叫做Data Node，负责保存分片数据。在数据扩展上起到了至关重要的作用</li></ul></li><li><ul><li>节点启动后，默认就是数据节点。可以设置node.data: false 禁止</li><li>由Master Node决定如何把分片分发到数据节点上</li><li>通过增加数据节点可以解决数据水平扩展和解决数据单点问题</li></ul></li><li><p>Coordinating Node</p></li><li><ul><li>负责接受Client的请求， 将请求分发到合适的节点，最终把结果汇集到一起</li><li>每个节点默认都起到了Coordinating Node的职责</li></ul></li></ul><p><strong>其他节点类型</strong></p><ul><li><p>Hot &amp; Warm Node</p></li><li><ul><li>不同硬件配置 的Data Node,用来实现Hot &amp; Warm架构，降低集群部署的成本</li></ul></li><li><p>Ingest Node</p></li><li><ul><li>数据前置处理转换节点，支持pipeline管道设置，可以使用ingest对数据进行过滤、转换等操作</li></ul></li><li><p>Machine Learning Node</p></li><li><ul><li>负责跑机器学习的Job，用来做异常检测</li></ul></li><li><p>Tribe Node</p></li><li><ul><li>Tribe Node连接到不同的Elasticsearch集群，并且支持将这些集群当成一个单独的集群处理</li></ul></li></ul><h3 id="分片-primary-shard-replica-shard" tabindex="-1"><a class="header-anchor" href="#分片-primary-shard-replica-shard" aria-hidden="true">#</a> 分片(Primary Shard &amp; Replica Shard)</h3><ul><li><p>主分片（Primary Shard）</p></li><li><ul><li>用以解决数据水平扩展的问题。通过主分片，可以将数据分布到集群内的所有节点之上</li><li>一个分片是一个运行的Lucene的实例</li><li>主分片数在索引创建时指定，后续不允许修改，除非Reindex</li></ul></li><li><p>副本分片（Replica Shard）</p></li><li><ul><li>用以解决数据高可用的问题。 副本分片是主分片的拷贝</li><li>副本分片数，可以动态调整</li><li>增加副本数，还可以在一定程度上提高服务的可用性(读取的吞吐)</li></ul></li></ul><p>​ # 指定索引的主分片和副本分片数 PUT /blogs { &quot;settings&quot;: { &quot;number_of_shards&quot;: 3, &quot;number_of_replicas&quot;: 1 } }</p><p>blogs对应的架构</p><p>​ <img src="https://img.jssjqd.cn//202305022150527.png" alt="image-20230502215053449" loading="lazy"></p><p>思考：增加一个节点或改大主分片数对系统有什么影响？</p><p><strong>分片的设定</strong></p><p>对于生产环境中分片的设定，需要提前做好容量规划</p><ul><li><p>分片数设置过小</p></li><li><ul><li>导致后续无法增加节点实现水平扩展</li><li>单个分片的数据量太大，导致数据重新分配耗时</li></ul></li><li><p>分片数设置过大，7.0 开始，默认主分片设置成1，解决了over-sharding（分片过度）的问题</p></li><li><ul><li>影响搜索结果的相关性打分，影响统计结果的准确性</li><li>单个节点上过多的分片，会导致资源浪费，同时也会影响性能</li></ul></li></ul><p>​ #查看集群的健康状况 GET _cluster/health</p><p><strong>集群status</strong></p><ul><li>Green: 主分片与副本都正常分配</li><li>Yellow: 主分片全部正常分配，有副本分片未能正常分配</li><li>Red: 有主分片未能分配。例如，当服务器的磁盘容量超过85%时,去创建了一个新的索引</li></ul><p><strong>CAT API查看集群信息：</strong></p><div class="language-json line-numbers-mode" data-ext="json"><pre class="language-json"><code>GET /_cat/nodes?v   #查看节点信息
GET /_cat/health?v    #查看集群当前状态：红、黄、绿
GET /_cat/shards?v        #查看各shard的详细情况  
GET /_cat/shards/<span class="token punctuation">{</span>index<span class="token punctuation">}</span>?v     #查看指定分片的详细情况
GET /_cat/master?v          #查看master节点信息
GET /_cat/indices?v         #查看集群中所有index的详细信息
GET /_cat/indices/<span class="token punctuation">{</span>index<span class="token punctuation">}</span>?v      #查看集群中指定index的详细信息
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="搭建三节点es集群" tabindex="-1"><a class="header-anchor" href="#搭建三节点es集群" aria-hidden="true">#</a> 搭建三节点ES集群</h2><p><strong>系统环境</strong></p><p>操作系统: CentOS7，准备用户es elasticsearch：elasticsearch-7.17.3</p><p>切换到root用户，修改/etc/hosts</p><div class="language-properties line-numbers-mode" data-ext="properties"><pre class="language-properties"><code><span class="token key attr-name">vim</span> <span class="token value attr-value"> /etc/hosts</span>
<span class="token key attr-name">192.168.65.174</span> <span class="token value attr-value">es-node1  </span>
<span class="token key attr-name">192.168.65.192</span> <span class="token value attr-value">es-node2  </span>
<span class="token key attr-name">192.168.65.204</span> <span class="token value attr-value">es-node3 </span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>修改elasticsearch.yml</strong></p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token comment"># 指定集群名称3个节点必须一致</span>
<span class="token key atrule">cluster.name</span><span class="token punctuation">:</span> es<span class="token punctuation">-</span>cluster
<span class="token comment">#指定节点名称，每个节点名字唯一</span>
<span class="token key atrule">node.name</span><span class="token punctuation">:</span> node<span class="token punctuation">-</span><span class="token number">1</span>
<span class="token comment">#是否有资格为master节点，默认为true</span>
<span class="token key atrule">node.master</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
<span class="token comment">#是否为data节点，默认为true</span>
<span class="token key atrule">node.data</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
<span class="token comment"># 绑定ip,开启远程访问,可以配置0.0.0.0</span>
<span class="token key atrule">network.host</span><span class="token punctuation">:</span> 0.0.0.0
<span class="token comment">#指定web端口</span>
<span class="token comment">#http.port: 9200</span>
<span class="token comment">#指定tcp端口</span>
<span class="token comment">#transport.tcp.port: 9300</span>
<span class="token comment">#用于节点发现</span>
<span class="token key atrule">discovery.seed_hosts</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">&quot;es-node1&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;es-node2&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;es-node3&quot;</span><span class="token punctuation">]</span>
<span class="token comment">#7.0新引入的配置项,初始仲裁，仅在整个集群首次启动时才需要初始仲裁。</span>
<span class="token comment">#该选项配置为node.name的值，指定可以初始化集群节点的名称</span>
<span class="token key atrule">cluster.initial_master_nodes</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">&quot;node-1&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;node-2&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;node-3&quot;</span><span class="token punctuation">]</span>
<span class="token comment">#解决跨域问题</span>
<span class="token key atrule">http.cors.enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
<span class="token key atrule">http.cors.allow-origin</span><span class="token punctuation">:</span> <span class="token string">&quot;*&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>三个节点配置如下：</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token comment">#192.168.65.174的配置</span>
<span class="token key atrule">cluster.name</span><span class="token punctuation">:</span> es<span class="token punctuation">-</span>cluster
<span class="token key atrule">node.name</span><span class="token punctuation">:</span> node<span class="token punctuation">-</span><span class="token number">1</span>
<span class="token key atrule">node.master</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
<span class="token key atrule">node.data</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
<span class="token key atrule">network.host</span><span class="token punctuation">:</span> 0.0.0.0
<span class="token key atrule">discovery.seed_hosts</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">&quot;es-node1&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;es-node2&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;es-node3&quot;</span><span class="token punctuation">]</span>
<span class="token key atrule">cluster.initial_master_nodes</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">&quot;node-1&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;node-2&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;node-3&quot;</span><span class="token punctuation">]</span>
<span class="token key atrule">http.cors.enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
<span class="token key atrule">http.cors.allow-origin</span><span class="token punctuation">:</span> <span class="token string">&quot;*&quot;</span>

<span class="token comment">#192.168.65.192的配置</span>
<span class="token key atrule">cluster.name</span><span class="token punctuation">:</span> es<span class="token punctuation">-</span>cluster
<span class="token key atrule">node.name</span><span class="token punctuation">:</span> node<span class="token punctuation">-</span><span class="token number">3</span>
<span class="token key atrule">node.master</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
<span class="token key atrule">node.data</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
<span class="token key atrule">network.host</span><span class="token punctuation">:</span> 0.0.0.0
<span class="token key atrule">discovery.seed_hosts</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">&quot;es-node1&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;es-node2&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;es-node3&quot;</span><span class="token punctuation">]</span>
<span class="token key atrule">cluster.initial_master_nodes</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">&quot;node-1&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;node-2&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;node-3&quot;</span><span class="token punctuation">]</span>
<span class="token key atrule">http.cors.enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
<span class="token key atrule">http.cors.allow-origin</span><span class="token punctuation">:</span> <span class="token string">&quot;*&quot;</span>

<span class="token comment">#192.168.65.204的配置</span>
<span class="token key atrule">cluster.name</span><span class="token punctuation">:</span> es<span class="token punctuation">-</span>cluster
<span class="token key atrule">node.name</span><span class="token punctuation">:</span> node<span class="token punctuation">-</span><span class="token number">2</span>
<span class="token key atrule">node.master</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
<span class="token key atrule">node.data</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
<span class="token key atrule">network.host</span><span class="token punctuation">:</span> 0.0.0.0
<span class="token key atrule">discovery.seed_hosts</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">&quot;es-node1&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;es-node2&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;es-node3&quot;</span><span class="token punctuation">]</span>
<span class="token key atrule">cluster.initial_master_nodes</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">&quot;node-1&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;node-2&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;node-3&quot;</span><span class="token punctuation">]</span>
<span class="token key atrule">http.cors.enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
<span class="token key atrule">http.cors.allow-origin</span><span class="token punctuation">:</span> <span class="token string">&quot;*&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>验证集群</p>`,52),u={href:"http://192.168.65.174:9200/_cat/nodes?pretty",target:"_blank",rel:"noopener noreferrer"},d=n("p",null,[s("​ "),n("img",{src:"https://img.jssjqd.cn//202305022156424.png",alt:"image-20230502215606657",loading:"lazy"})],-1),m=n("h3",{id:"安装cerebro客户端",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#安装cerebro客户端","aria-hidden":"true"},"#"),s(" 安装Cerebro客户端")],-1),v=n("p",null,[n("strong",null,"Cerebro介绍")],-1),k=n("p",null,"Cerebro 可以查看分片分配和通过图形界面执行常见的索引操作。 完全开源，并且它允许添加用户，密码或 LDAP 身份验证问网络界面。",-1),b=n("p",null,"Cerebro 基于 Scala 的Play 框架编写，用于后端 REST 和 Elasticsearch 通信。 它使用通过 AngularJS 编写的单页应用程序（SPA）前端。",-1),g={href:"https://github.com/lmenezes/cerebro",target:"_blank",rel:"noopener noreferrer"},h=n("p",null,[n("strong",null,"安装 Cerebro")],-1),q={href:"https://github.com/lmenezes/cerebro/releases/download/v0.9.4/cerebro-0.9.4.zip",target:"_blank",rel:"noopener noreferrer"},_=l(`<p><strong>运行 cerebro</strong></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>cerebro-0.9.4/bin/cerebro

<span class="token comment">#后台启动</span>
<span class="token function">nohup</span> bin/cerebro <span class="token operator">&gt;</span> cerebro.log <span class="token operator">&amp;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,2),y={href:"http://192.168.65.174:9000/",target:"_blank",rel:"noopener noreferrer"},f=n("figure",null,[n("img",{src:"https://img.jssjqd.cn//202305022156129.png",alt:"image-20230502215635053",tabindex:"0",loading:"lazy"}),n("figcaption",null,"image-20230502215635053")],-1),x={href:"http://192.168.65.192:9200",target:"_blank",rel:"noopener noreferrer"},E=l(`<figure><img src="https://img.jssjqd.cn//202305022156090.png" alt="image-20230502215644281" tabindex="0" loading="lazy"><figcaption>image-20230502215644281</figcaption></figure><h3 id="安装kibana" tabindex="-1"><a class="header-anchor" href="#安装kibana" aria-hidden="true">#</a> 安装kibana</h3><p>修改kibana配置</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code>vim config/kibana.yml

<span class="token key atrule">server.port</span><span class="token punctuation">:</span> <span class="token number">5601</span>
<span class="token key atrule">server.host</span><span class="token punctuation">:</span> <span class="token string">&quot;192.168.65.174&quot;</span> 
<span class="token key atrule">elasticsearch.hosts</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">&quot;http://192.168.65.174:9200&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;http://192.168.65.192:9200&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;http://192.168.65.204:9200&quot;</span><span class="token punctuation">]</span>  
<span class="token key atrule">i18n.locale</span><span class="token punctuation">:</span> <span class="token string">&quot;zh-CN&quot;</span> 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>运行Kibana</strong></p><p>提示：Kibana对外的 tcp 端口是5601，使用netstat -tunlp|grep 5601即可查看进程</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment">#后台启动</span>
<span class="token function">nohup</span>  bin/kibana <span class="token operator">&amp;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div>`,7),S=n("strong",null,"访问Kibana:",-1),j={href:"http://192.168.65.174:5601/",target:"_blank",rel:"noopener noreferrer"},T=n("strong",null,"http://192.168.65.174:5601/",-1),C=n("h2",{id:"es安全认证",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#es安全认证","aria-hidden":"true"},"#"),s(" ES安全认证")],-1),P={href:"https://www.elastic.co/guide/en/elasticsearch/reference/7.17/configuring-stack-security.html",target:"_blank",rel:"noopener noreferrer"},w=n("h3",{id:"es敏感信息泄露的原因",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#es敏感信息泄露的原因","aria-hidden":"true"},"#"),s(" ES敏感信息泄露的原因")],-1),N=n("ul",null,[n("li",null,"Elasticsearch在默认安装后，不提供任何形式的安全防护"),n("li",null,"不合理的配置导致公网可以访问ES集群。比如在elasticsearch.yml文件中,server.host配置为0.0.0.0")],-1),M=n("h3",{id:"免费的方案",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#免费的方案","aria-hidden":"true"},"#"),s(" 免费的方案")],-1),G=n("li",null,[n("p",null,"设置nginx反向代理")],-1),z=n("li",null,[n("p",null,"安装免费的Security插件")],-1),B={href:"https://search-guard.com/",target:"_blank",rel:"noopener noreferrer"},U={href:"https://readonlyrest.com/",target:"_blank",rel:"noopener noreferrer"},D=n("li",null,[n("p",null,"X-Pack的Basic版")],-1),A=n("li",null,[n("ul",null,[n("li",null,"从ES 6.8开始，Security纳入x-pack的Basic版本中，免费使用一些基本的功能")])],-1),I=l(`<h3 id="集群内部安全通信" tabindex="-1"><a class="header-anchor" href="#集群内部安全通信" aria-hidden="true">#</a> 集群内部安全通信</h3><p>ElasticSearch集群内部的数据是通过9300进行传输的，如果不对数据加密，可能会造成数据被抓包，敏感信息泄露。</p><p>解决方案： 为节点创建证书</p><p>TLS 协议要求Trusted Certificate Authority (CA）签发x.509的证书。证书认证的不同级别：</p><ul><li>Certificate ——节点加入需要使用相同CA签发的证书</li><li>Full Verification——节点加入集群需要相同CA签发的证书，还需要验证Host name 或IP地址</li><li>No Verification——任何节点都可以加入，开发环境中用于诊断目的</li></ul><p><strong>1）生成节点证书</strong></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 为集群创建一个证书颁发机构</span>
bin/elasticsearch-certutil ca
<span class="token comment"># 为集群中的每个节点生成证书和私钥</span>
bin/elasticsearch-certutil cert <span class="token parameter variable">--ca</span> elastic-stack-ca.p12
<span class="token comment"># 移动到config目录下</span>
<span class="token function">mv</span> *.p12 config/
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>将如上命令生成的两个证书文件拷贝到另外两个节点作为通信依据。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 拷贝到192.168.65.192</span>
<span class="token function">scp</span> *.p12 es@192.168.65.192:/home/es/elasticsearch-7.17.3/config
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>2）配置节点间通信</strong></p><p>三个ES节点增加如下配置：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment">## elasticsearch.yml 配置</span>
xpack.security.transport.ssl.enabled: <span class="token boolean">true</span>
xpack.security.transport.ssl.verification_mode: certificate 
xpack.security.transport.ssl.client_authentication: required
xpack.security.transport.ssl.keystore.path: elastic-certificates.p12
xpack.security.transport.ssl.truststore.path: elastic-certificates.p12
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="开启并配置x-pack的认证" tabindex="-1"><a class="header-anchor" href="#开启并配置x-pack的认证" aria-hidden="true">#</a> 开启并配置X-Pack的认证</h3><p>1）修改elasticsearch.yml配置文件，开启xpack认证机制</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">xpack.security.enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true</span> <span class="token comment"># 开启xpack认证机制</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>测试：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment">#使用Curl访问ES，返回401错误</span>
<span class="token function">curl</span> <span class="token string">&#39;localhost:9200/_cat/nodes?pretty&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://img.jssjqd.cn//202305022219714.png" alt="image-20230502221951814" tabindex="0" loading="lazy"><figcaption>image-20230502221951814</figcaption></figure>`,18),R={href:"http://192.168.65.174:9200/%E9%9C%80%E8%A6%81%E8%BE%93%E5%85%A5%E7%94%A8%E6%88%B7%E5%90%8D%E5%AF%86%E7%A0%81",target:"_blank",rel:"noopener noreferrer"},O=l(`<p>​ <img src="https://img.jssjqd.cn//202305022219134.png" alt="image-20230502221956207" loading="lazy"></p><p>2）为内置账号添加密码</p><p>ES中内置了几个管理其他集成组件的账号即：apm_system, beats_system, elastic, kibana,</p><p>logstash_system, remote_monitoring_user，使用之前，首先需要添加一下密码。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>bin/elasticsearch-setup-passwords interactive
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>interactive：给用户手动设置密码。</li><li>auto：自动生成密码。</li></ul><p>​ <img src="https://img.jssjqd.cn//202305022220273.png" alt="image-20230502222019511" loading="lazy"></p><p>测试</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">curl</span> <span class="token parameter variable">-u</span> elastic <span class="token string">&#39;localhost:9200/_cat/nodes?pretty&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://img.jssjqd.cn//202305022220829.png" alt="image-20230502222039004" tabindex="0" loading="lazy"><figcaption>image-20230502222039004</figcaption></figure><p>3）配置Kibana</p><p>开启了安全认证之后，kibana连接es以及访问es都需要认证。</p><p>修改kibana.yml</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">elasticsearch.username</span><span class="token punctuation">:</span> <span class="token string">&quot;kibana_system&quot;</span>
<span class="token key atrule">elasticsearch.password</span><span class="token punctuation">:</span> <span class="token string">&quot;123456&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>启动kibana服务</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">nohup</span>  bin/kibana <span class="token operator">&amp;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>4）配置cerebro</p><p>修改配置文件</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">vim</span> conf/application.conf

hosts <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token punctuation">{</span>
    <span class="token function">host</span> <span class="token operator">=</span> <span class="token string">&quot;http://192.168.65.174:9200&quot;</span>
    name <span class="token operator">=</span> <span class="token string">&quot;es-cluster&quot;</span>
    auth <span class="token operator">=</span> <span class="token punctuation">{</span>
      username <span class="token operator">=</span> <span class="token string">&quot;elastic&quot;</span>
      password <span class="token operator">=</span> <span class="token string">&quot;123456&quot;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">]</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://img.jssjqd.cn//202305022221202.png" alt="image-20230502222113494" tabindex="0" loading="lazy"><figcaption>image-20230502222113494</figcaption></figure><p>启动cerebro服务</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">nohup</span> bin/cerebro <span class="token operator">&gt;</span> cerebro.log <span class="token operator">&amp;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="生产环境常见集群部署方式" tabindex="-1"><a class="header-anchor" href="#生产环境常见集群部署方式" aria-hidden="true">#</a> 生产环境常见集群部署方式</h2><p>不同角色的节点：Master eligible / Data / Ingest / Coordinating /Machine Learning</p><p>在开发环境中，一个节点可承担多种角色。</p><p>在生产环境中：</p><ul><li>根据数据量，写入和查询的吞吐量，选择合适的部署方式</li><li>建议设置单一角色的节点</li></ul><figure><img src="https://img.jssjqd.cn//202305022221380.png" alt="image-20230502222135634" tabindex="0" loading="lazy"><figcaption>image-20230502222135634</figcaption></figure><p>一个节点只承担一个角色的配置</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token comment">#Master节点</span>
<span class="token key atrule">node.master</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
<span class="token key atrule">node.ingest</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>
<span class="token key atrule">node.data</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>

<span class="token comment">#data节点</span>
<span class="token key atrule">node.master</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>
<span class="token key atrule">node.ingest</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>
<span class="token key atrule">node.data</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>

<span class="token comment">#ingest 节点</span>
<span class="token key atrule">node.master</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>
<span class="token key atrule">node.ingest</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
<span class="token key atrule">node.data</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>

<span class="token comment">#coordinate节点</span>
<span class="token key atrule">node.master</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>
<span class="token key atrule">node.ingest</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>
<span class="token key atrule">node.data</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种单一角色职责分离的好处：</p><ul><li><p>单一 master eligible nodes: 负责集群状态(cluster state)的管理</p></li><li><ul><li>使用低配置的CPU,RAM和磁盘</li></ul></li><li><p>单一 data nodes: 负责数据存储及处理客户端请求</p></li><li><ul><li>使用高配置的CPU,RAM和磁盘</li></ul></li><li><p>单一ingest nodes: 负责数据处理</p></li><li><ul><li>使用高配置CPU; 中等配置的RAM; 低配置的磁盘</li></ul></li><li><p>单一Coordinating Only Nodes(Client Node)</p></li><li><ul><li>使用高配置CPU; 高配置的RAM; 低配置的磁盘</li></ul></li></ul><p>生产环境中，建议为一些大的集群配置Coordinating Only Nodes</p><ul><li>扮演Load Balancers，降低Master和 Data Nodes的负载</li><li>负责搜索结果的Gather/Reduce</li><li>有时候无法预知客户端会发送怎么样的请求。比如大量占用内存的操作，一个深度聚合可能会引发OOM</li></ul><p><strong>单一 master eligible nodes</strong></p><p>从高可用&amp;避免脑裂的角度出发：</p><ul><li><p>一般在生产环境中配置3台</p></li><li><p>一个集群只有1台活跃的主节点（master node）</p></li><li><ul><li>负责分片管理，索引创建，集群管理等操作</li></ul></li><li><p>如果和数据节点或者Coordinate节点混合部署</p></li><li><ul><li>数据节点相对有比较大的内存占用</li><li>Coordinate节点有时候可能会有开销很高的查询，导致OOM</li><li>这些都有可能影响Master节点，导致集群的不稳定</li></ul></li></ul><h3 id="增加节点水平扩展场景" tabindex="-1"><a class="header-anchor" href="#增加节点水平扩展场景" aria-hidden="true">#</a> 增加节点水平扩展场景</h3><ul><li>当磁盘容量无法满足需求时，可以增加数据节点；</li><li>磁盘读写压力大时，增加数据节点</li><li>当系统中有大量的复杂查询及聚合时候，增加Coordinating节点，增加查询的性能</li></ul><p>​ <img src="https://img.jssjqd.cn//202305022222189.png" alt="image-20230502222204231" loading="lazy"></p><h3 id="读写分离架构" tabindex="-1"><a class="header-anchor" href="#读写分离架构" aria-hidden="true">#</a> 读写分离架构</h3><p>​ <img src="https://img.jssjqd.cn//202305022222593.png" alt="image-20230502222208369" loading="lazy"></p><h3 id="异地多活架构" tabindex="-1"><a class="header-anchor" href="#异地多活架构" aria-hidden="true">#</a> 异地多活架构</h3><p>集群处在三个数据中心，数据三写，GTM分发读请求</p><p>​ <img src="https://img.jssjqd.cn//202305022222023.png" alt="image-20230502222212160" loading="lazy"></p><p>全局流量管理（GTM）和负载均衡（SLB）的区别：</p><p>GTM 是通过DNS将域名解析到多个IP地址，不同用户访问不同的IP地址，来实现应用服务流量的分配。同时通过健康检查动态更新DNS解析IP列表，实现故障隔离以及故障切换。最终用户的访问直接连接服务的IP地址，并不通过GTM。而 SLB 是通过代理用户访问请求的形式将用户访问请求实时分发到不同的服务器，最终用户的访问流量必须要经过SLB。 一般来说，相同Region使用SLB进行负载均衡，不同region的多个SLB地址时，则可以使用GTM进行负载均衡。</p><p>ES 跨集群复制 （Cross-Cluster Replication）是ES 6.7的的一个全局高可用特性。CCR允许不同的索引复制到一个或多个ES 集群中。</p>`,48),L={href:"https://www.elastic.co/guide/en/elasticsearch/reference/7.17/ccr-apis.html",target:"_blank",rel:"noopener noreferrer"},F=l('<h3 id="hot-warm-架构" tabindex="-1"><a class="header-anchor" href="#hot-warm-架构" aria-hidden="true">#</a> Hot &amp; Warm 架构</h3><p>为什么要设计Hot &amp; Warm 架构？</p><ul><li>ES数据通常不会有 Update操作;</li><li>适用于Time based索引数据，同时数据量比较大的场景。</li><li>引入 Warm节点，低配置大容量的机器存放老数据，以降低部署成本</li></ul><p>两类数据节点，不同的硬件配置：</p><ul><li>Hot节点(通常使用SSD)︰索引不断有新文档写入。</li><li>Warm 节点（通常使用HDD)︰索引不存在新数据的写入，同时也不存在大量的数据查询</li></ul><p><strong>Hot Nodes</strong></p><p>用于数据的写入：</p><ul><li>lndexing 对 CPU和IO都有很高的要求，所以需要使用高配置的机器</li><li>存储的性能要好，建议使用SSD</li></ul><p>​</p><p><strong>Warm Nodes</strong></p><p>用于保存只读的索引，比较旧的数据。通常使用大容量的磁盘</p><p>​ <img src="https://img.jssjqd.cn//202305022222381.png" alt="image-20230502222220601" loading="lazy"></p><h3 id="配置hot-warm-架构" tabindex="-1"><a class="header-anchor" href="#配置hot-warm-架构" aria-hidden="true">#</a> 配置Hot &amp; Warm 架构</h3><p><strong>使用Shard Filtering实现Hot&amp;Warm node间的数据迁移</strong></p><ul><li>node.attr来指定node属性：hot或是warm。</li><li>在index的settings里通过index.routing.allocation来指定索引（index)到一个满足要求的node</li></ul>',15),H=n("table",null,[n("thead",null,[n("tr",null,[n("th",null,"设置"),n("th",null,"分配索引到节点，节点的属性规则")])]),n("tbody",null,[n("tr",null,[n("td",{attr:""},"index.routing.allocation.include."),n("td",null,"至少包含一个值")]),n("tr",null,[n("td",{attr:""},"index.routina.allocation.exclude."),n("td",null,"不能包含任何一个值")]),n("tr",null,[n("td",{attr:""},"index.routina.allocation.require."),n("td",null,"所有值都需要包含")])])],-1),W=l(`<p>使用 Shard Filtering，步骤分为以下几步:</p><ul><li>标记节点(Tagging)</li><li>配置索引到Hot Node</li><li>配置索引到 Warm节点</li></ul><p><strong>1) 标记节点</strong></p><p>需要通过“node.attr”来标记一个节点</p><ul><li>节点的attribute可以是任何的key/value</li><li>可以通过elasticsearch.yml 或者通过-E命令指定</li></ul><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token comment"># 标记一个 Hot 节点</span>
elasticsearch.bat  <span class="token punctuation">-</span>E node.name=hotnode <span class="token punctuation">-</span>E cluster.name=tulingESCluster <span class="token punctuation">-</span>E http.port=9200 <span class="token punctuation">-</span>E path.data=hot_data <span class="token punctuation">-</span>E node.attr.my_node_type=hot

<span class="token comment"># 标记一个 warm 节点</span>
elasticsearch.bat  <span class="token punctuation">-</span>E node.name=warmnode <span class="token punctuation">-</span>E cluster.name=tulingESCluster <span class="token punctuation">-</span>E http.port=9201 <span class="token punctuation">-</span>E path.data=warm_data <span class="token punctuation">-</span>E node.attr.my_node_type=warm

<span class="token comment"># 查看节点</span>
GET /_cat/nodeattrs<span class="token punctuation">?</span>v
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://img.jssjqd.cn//202305022222095.png" alt="image-20230502222247263" tabindex="0" loading="lazy"><figcaption>image-20230502222247263</figcaption></figure><p><strong>2）配置Hot数据</strong></p><p>创建索引时候，指定将其创建在hot节点上</p><div class="language-json line-numbers-mode" data-ext="json"><pre class="language-json"><code># 配置到 Hot节点
PUT /index<span class="token number">-2022</span><span class="token number">-05</span>
<span class="token punctuation">{</span>
  <span class="token property">&quot;settings&quot;</span><span class="token operator">:</span><span class="token punctuation">{</span>
    <span class="token property">&quot;number_of_shards&quot;</span><span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">,</span>
    <span class="token property">&quot;number_of_replicas&quot;</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">,</span>
    <span class="token property">&quot;index.routing.allocation.require.my_node_type&quot;</span><span class="token operator">:</span><span class="token string">&quot;hot&quot;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

POST /index<span class="token number">-2022</span><span class="token number">-05</span>/_doc
<span class="token punctuation">{</span>
  <span class="token property">&quot;create_time&quot;</span><span class="token operator">:</span><span class="token string">&quot;2022-05-27&quot;</span>
<span class="token punctuation">}</span>

#查看索引文档的分布
GET _cat/shards/index<span class="token number">-2022</span><span class="token number">-05</span>?v
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>​</p><p>​ <img src="https://img.jssjqd.cn//202305022223661.png" alt="image-20230502222308822" loading="lazy"></p><p><strong>3）旧数据移动到Warm节点</strong></p><p>Index.routing.allocation是一个索引级的dynamic setting,可以通过API在后期进行设定</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code># 配置到 warm 节点
PUT /index-2022-05/_settings
{  
  &quot;index.routing.allocation.require.my_node_type&quot;:&quot;warm&quot;
}
GET _cat/shards/index-2022-05?v     
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>​ <img src="https://img.jssjqd.cn//202305022223968.png" alt="image-20230502222321187" loading="lazy"></p><h3 id="如何对集群的容量进行规划" tabindex="-1"><a class="header-anchor" href="#如何对集群的容量进行规划" aria-hidden="true">#</a> 如何对集群的容量进行规划</h3><p>一个集群总共需要多少个节点?一个索引需要设置几个分片？规划上需要保持一定的余量，当负载出现波动，节点出现丢失时，还能正常运行。</p><p>做容量规划时，一些需要考虑的因素：</p><ul><li>机器的软硬件配置</li><li>单条文档的大小│文档的总数据量│索引的总数据量（(Time base数据保留的时间)|副本分片数</li><li>文档是如何写入的(Bulk的大小)</li><li>文档的复杂度，文档是如何进行读取的(怎么样的查询和聚合)</li></ul><p>评估业务的性能需求：</p><ul><li><p>数据吞吐及性能需求</p></li><li><ul><li>数据写入的吞吐量，每秒要求写入多少数据?</li><li>查询的吞吐量?</li><li>单条查询可接受的最大返回时间?</li></ul></li><li><p>了解你的数据</p></li><li><ul><li>数据的格式和数据的Mapping</li><li>实际的查询和聚合长的是什么样的</li></ul></li></ul><p>ES集群常见应用场景：</p><ul><li><p>搜索: 固定大小的数据集</p></li><li><ul><li>搜索的数据集增长相对比较缓慢</li></ul></li><li><p>日志: 基于时间序列的数据</p></li><li><ul><li>使用ES存放日志与性能指标。数据每天不断写入，增长速度较快</li><li>结合Warm Node 做数据的老化处理</li></ul></li></ul><p>硬件配置：</p><ul><li><p>选择合理的硬件，数据节点尽可能使用SSD</p></li><li><p>搜索等性能要求高的场景，建议SSD</p></li><li><ul><li>按照1∶10的比例配置内存和硬盘</li></ul></li><li><p>日志类和查询并发低的场景，可以考虑使用机械硬盘存储</p></li><li><ul><li>按照1:50的比例配置内存和硬盘</li></ul></li><li><p>单节点数据建议控制在2TB以内，最大不建议超过5TB</p></li><li><p>JVM配置机器内存的一半，JVM内存配置不建议超过32G</p></li><li><p>不建议在一台服务器上运行多个节点</p></li></ul><p>内存大小要根据Node 需要存储的数据来进行估算</p><ul><li>搜索类的比例建议: 1:16</li><li>日志类: 1:48——1:96之间</li></ul><p>假设总数据量1T，设置一个副本就是2T总数据量</p><ul><li>如果搜索类的项目，每个节点31*16 = 496 G，加上预留空间。所以每个节点最多400G数据，至少需要5个数据节点</li><li>如果是日志类项目，每个节点31*50= 1550 GB，2个数据节点即可</li></ul><p>部署方式：</p><ul><li>按需选择合理的部署方式</li><li>如果需要考虑可靠性高可用，建议部署3台单一的Master节点</li><li>如果有复杂的查询和聚合，建议设置Coordinating节点</li></ul><p>集群扩容：</p><ul><li><p>增加Coordinating / Ingest Node</p></li><li><ul><li>解决CPU和内存开销的问题</li></ul></li><li><p>增加数据节点</p></li><li><ul><li>解决存储的容量的问题</li><li>为避免分片分布不均的问题，要提前监控磁盘空间，提前清理数据或增加节点</li></ul></li></ul><p><strong>容量规划案例1: 产品信息库搜索</strong></p><p>特性：</p><ul><li>被搜索的数据集很大，但是增长相对比较慢(不会有大量的写入)。更关心搜索和聚合的读取性能</li><li>数据的重要性与时间范围无关。关注的是搜索的相关度</li></ul><p>估算索引的的数据量，然后确定分片的大小：</p><ul><li>单个分片的数据不要超过20 GB</li><li>可以通过增加副本分片，提高查询的吞吐量</li></ul><p>思考：如果单个索引数据量非常大，如何优化提升查询性能？</p><p>拆分索引</p><ul><li><p>如果业务上有大量的查询是基于一个字段进行Filter，该字段又是一个数量有限的枚举值。</p></li><li><ul><li>例如订单所在的地区。可以考虑以地区进行索引拆分</li></ul></li></ul><p>如果在单个索引有大量的数据，可以考虑将索引拆分成多个索引：</p><ul><li><p>查询性能可以得到提高</p></li><li><p>如果要对多个索引进行查询，还是可以在查询中指定多个索引得以实现</p></li><li><p>如果业务上有大量的查询是基于一个字段进行Filter，该字段数值并不固定</p></li><li><ul><li>可以启用Routing 功能，按照filter 字段的值分布到集群中不同的shard，降低查询时相关的shard数提高CPU利用率</li></ul></li></ul><div class="language-json line-numbers-mode" data-ext="json"><pre class="language-json"><code>es分片路由的规则<span class="token operator">:</span>
shard_num = hash(_routing) % num_primary_shards
_routing字段的取值，默认是_id字段，可以自定义。

PUT /users
<span class="token punctuation">{</span>
  <span class="token property">&quot;settings&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">&quot;number_of_shards&quot;</span><span class="token operator">:</span><span class="token number">2</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
POST /users/_create/<span class="token number">1</span>?routing=fox
<span class="token punctuation">{</span>
  <span class="token property">&quot;name&quot;</span><span class="token operator">:</span><span class="token string">&quot;fox&quot;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>容量规划案例2: 基于时间序列的数据</strong></p><p>相关场景：</p><ul><li>日志/指标/安全相关的事件</li><li>舆情分析</li></ul><p>特性：</p><ul><li>每条数据都有时间戳，文档基本不会被更新(日志和指标数据)</li><li>用户更多的会查询近期的数据，对旧的数据查询相对较少</li><li>对数据的写入性能要求比较高</li></ul><p>创建基于时间序列的索引：</p><ul><li>在索引的名字中增加时间信息</li><li>按照每天/每周/每月的方式进行划分</li></ul><p>这样做的好处：更加合理的组织索引，例如随着时间推移，便于对索引做的老化处理。</p><ul><li>可以利用Hot &amp; Warm 架构</li><li>备份和删除以及删除的效率高。(Delete By Query执行速度慢，底层也不会立刻释放空间)</li></ul><p>基于Date Math方式建立索引</p><p>比如：假设当前日期 2022-05-27</p><figure><img src="https://img.jssjqd.cn//202305022226719.png" alt="image-20230502222648524" tabindex="0" loading="lazy"><figcaption>image-20230502222648524</figcaption></figure><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># PUT /&lt;logs-{now/d}</span>
PUT /%3Clogs-%7Bnow%2Fd%7D%3E

<span class="token comment"># POST /&lt;logs-{now/d}&gt;/_search</span>
POST /%3Clogs-%7Bnow%2Fd%7D%3E/_search
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>基于Index Alias索引最新的数据</p><div class="language-json line-numbers-mode" data-ext="json"><pre class="language-json"><code>PUT /logs_2022<span class="token number">-05</span><span class="token number">-27</span>
PUT /logs_2022<span class="token number">-05</span><span class="token number">-26</span>

#可以每天晚上定时执行
POST /_aliases
<span class="token punctuation">{</span>
  <span class="token property">&quot;actions&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span>
      <span class="token property">&quot;add&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token property">&quot;index&quot;</span><span class="token operator">:</span> <span class="token string">&quot;logs_2022-05-27&quot;</span><span class="token punctuation">,</span>
        <span class="token property">&quot;alias&quot;</span><span class="token operator">:</span> <span class="token string">&quot;logs_write&quot;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
      <span class="token property">&quot;remove&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token property">&quot;index&quot;</span><span class="token operator">:</span> <span class="token string">&quot;logs_2022-05-26&quot;</span><span class="token punctuation">,</span>
        <span class="token property">&quot;alias&quot;</span><span class="token operator">:</span> <span class="token string">&quot;logs_write&quot;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span>

GET /logs_write
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="es跨集群搜索-ccs" tabindex="-1"><a class="header-anchor" href="#es跨集群搜索-ccs" aria-hidden="true">#</a> ES跨集群搜索（CCS）</h2><h3 id="es水平扩展存在的问题" tabindex="-1"><a class="header-anchor" href="#es水平扩展存在的问题" aria-hidden="true">#</a> ES水平扩展存在的问题</h3><ul><li><p>单集群水平扩展时，节点数不能无限增加</p></li><li><ul><li>当集群的meta 信息(节点，索引，集群状态)过多会导致更新压力变大，单个Active Master会成为性能瓶颈，导致整个集群无法正常工作</li></ul></li><li><p>早期版本，通过Tribe Node可以实现多集群访问的需求，但是还存在一定的问题</p></li><li><ul><li>Tribe Node会以Client Node的方式加入每个集群，集群中Master节点的任务变更需要Tribe Node 的回应才能继续。</li><li>Tribe Node 不保存Cluster State信息，一旦重启，初始化很慢</li><li>当多个集群存在索引重名的情况时，只能设置一种 Prefer 规则</li></ul></li></ul><h3 id="跨集群搜索实战" tabindex="-1"><a class="header-anchor" href="#跨集群搜索实战" aria-hidden="true">#</a> 跨集群搜索实战</h3><p>早期Tribe Node 的方案存在一定的问题，现已被弃用。Elasticsearch 5.3引入了跨集群搜索的功能(Cross Cluster Search)，推荐使用</p><ul><li>允许任何节点扮演联合节点，以轻量的方式，将搜索请求进行代理</li><li>不需要以Client Node的形式加入其他集群</li></ul><p><strong>配置集群</strong></p><div class="language-json line-numbers-mode" data-ext="json"><pre class="language-json"><code><span class="token comment">//启动3个集群</span>
elasticsearch.bat -E node.name=cluster0node -E cluster.name=cluster0 -E path.data=cluster0_data -E discovery.type=single-node -E http.port=<span class="token number">9200</span> -E transport.port=<span class="token number">9300</span>
elasticsearch.bat -E node.name=cluster1node -E cluster.name=cluster1 -E path.data=cluster1_data -E discovery.type=single-node -E http.port=<span class="token number">9201</span> -E transport.port=<span class="token number">9301</span>
elasticsearch.bat -E node.name=cluster2node -E cluster.name=cluster2 -E path.data=cluster2_data -E discovery.type=single-node -E http.port=<span class="token number">9202</span> -E transport.port=<span class="token number">9302</span>

<span class="token comment">//在每个集群上设置动态的设置</span>
PUT _cluster/settings
<span class="token punctuation">{</span>
  <span class="token property">&quot;persistent&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">&quot;cluster&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token property">&quot;remote&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token property">&quot;cluster0&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
          <span class="token property">&quot;seeds&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span>
            <span class="token string">&quot;127.0.0.1:9300&quot;</span>
          <span class="token punctuation">]</span><span class="token punctuation">,</span>
          <span class="token property">&quot;transport.ping_schedule&quot;</span><span class="token operator">:</span> <span class="token string">&quot;30s&quot;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token property">&quot;cluster1&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
          <span class="token property">&quot;seeds&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span>
            <span class="token string">&quot;127.0.0.1:9301&quot;</span>
          <span class="token punctuation">]</span><span class="token punctuation">,</span>
          <span class="token property">&quot;transport.compress&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
          <span class="token property">&quot;skip_unavailable&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token property">&quot;cluster2&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
          <span class="token property">&quot;seeds&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span>
            <span class="token string">&quot;127.0.0.1:9302&quot;</span>
          <span class="token punctuation">]</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>CCS的配置：</p><p>1）seeds</p><p>配置的远程集群的remote cluster的一个node。</p><p>2）connected</p><p>如果至有少一个到远程集群的连接则为true。</p><p>3）num_nodes_connected</p><p>远程集群中连接节点的数量。</p><p>4）max_connections_per_cluster</p><p>远程集群维护的最大连接数。</p><p>5）transport.ping_schedule</p><p>设置了tcp层面的活性监听</p><p>6）skip_unavailable</p><p>设置为true的话，当这个remote cluster不可用的时候，就会忽略，默认是false，当对应的remote cluster不可用的话，则会报错。</p><p>7）cluster.remote.connections_per_cluster</p><p>gateway nodes数量，默认是3</p><p>8）cluster.remote.initial_connect_timeout</p><p>节点启动时等待远程节点的超时时间，默认是30s</p><p>9）cluster.remote.node.attr：</p><p>一个节点属性，用于过滤掉remote cluster中 符合gateway nodes的节点，比如设置cluster.remote.node.attr=gateway，那么将匹配节点属性node.attr.gateway: true 的node才会被该node连接用来做CCS查询。</p><p>10）cluster.remote.connect：</p><p>默认情况下，群集中的任意节点都可以充当federated client并连接到remote cluster，cluster.remote.connect可以设置为 false（默认为true）以防止某些节点连接到remote cluster</p><p>11）在使用api进行动态设置的时候每次都要把seeds带上</p><p><strong>创建测试数据</strong></p><div class="language-json line-numbers-mode" data-ext="json"><pre class="language-json"><code>#在不同集群上执行
# cluster0 localhost<span class="token operator">:</span><span class="token number">9200</span>
POST /users/_doc
<span class="token punctuation">{</span>
    <span class="token property">&quot;name&quot;</span><span class="token operator">:</span><span class="token string">&quot;fox&quot;</span><span class="token punctuation">,</span>
    <span class="token property">&quot;age&quot;</span><span class="token operator">:</span><span class="token string">&quot;30&quot;</span>
<span class="token punctuation">}</span>

#cluster1  localhost<span class="token operator">:</span><span class="token number">9201</span>
POST /users/_doc
<span class="token punctuation">{</span>
    <span class="token property">&quot;name&quot;</span><span class="token operator">:</span><span class="token string">&quot;monkey&quot;</span><span class="token punctuation">,</span>
    <span class="token property">&quot;age&quot;</span><span class="token operator">:</span><span class="token string">&quot;33&quot;</span>
<span class="token punctuation">}</span>

#cluster2  localhost<span class="token operator">:</span><span class="token number">9202</span>
POST /users/_doc
<span class="token punctuation">{</span>
    <span class="token property">&quot;name&quot;</span><span class="token operator">:</span><span class="token string">&quot;mark&quot;</span><span class="token punctuation">,</span>
    <span class="token property">&quot;age&quot;</span><span class="token operator">:</span><span class="token string">&quot;35&quot;</span>
<span class="token punctuation">}</span>     
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>查询</strong></p><div class="language-json line-numbers-mode" data-ext="json"><pre class="language-json"><code>#查询结果获取到所有集群符合要求的数据
GET /users<span class="token punctuation">,</span>cluster1<span class="token operator">:</span>users<span class="token punctuation">,</span>cluster2<span class="token operator">:</span>users/_search
<span class="token punctuation">{</span>
  <span class="token property">&quot;query&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">&quot;range&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token property">&quot;age&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token property">&quot;gte&quot;</span><span class="token operator">:</span> <span class="token number">30</span><span class="token punctuation">,</span>
        <span class="token property">&quot;lte&quot;</span><span class="token operator">:</span> <span class="token number">40</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="分片的设计和管理" tabindex="-1"><a class="header-anchor" href="#分片的设计和管理" aria-hidden="true">#</a> 分片的设计和管理</h2><p><strong>单个分片</strong></p><ul><li>7.0开始，新创建一个索引时，默认只有一个主分片。单个分片，查询算分，聚合不准的问题都可以得以避免</li><li>单个索引，单个分片时候，集群无法实现水平扩展。即使增加新的节点，无法实现水平扩展</li></ul><p><strong>两个分片</strong></p><p>集群增加一个节点后，Elasticsearch 会自动进行分片的移动，也叫 Shard Rebalancing</p><figure><img src="https://img.jssjqd.cn//202305022228300.png" alt="image-20230502222826506" tabindex="0" loading="lazy"><figcaption>image-20230502222826506</figcaption></figure><p><strong>算分不准的原因</strong></p><p>相关性算分在分片之间是相互独立的，每个分片都基于自己的分片上的数据进行相关度计算。这会导致打分偏离的情况，特别是数据量很少时。当文档总数很少的情况下，如果主分片大于1，主分片数越多，相关性算分会越不准</p><p><strong>Demo</strong></p><div class="language-json line-numbers-mode" data-ext="json"><pre class="language-json"><code>PUT /blogs
<span class="token punctuation">{</span>
  <span class="token property">&quot;settings&quot;</span><span class="token operator">:</span><span class="token punctuation">{</span>
    <span class="token property">&quot;number_of_shards&quot;</span> <span class="token operator">:</span> <span class="token string">&quot;3&quot;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

POST /blogs/_doc/<span class="token number">1</span>?routing=fox
<span class="token punctuation">{</span>
 <span class="token property">&quot;content&quot;</span><span class="token operator">:</span><span class="token string">&quot;Cross Cluster elasticsearch Search&quot;</span>
<span class="token punctuation">}</span>

POST /blogs/_doc/<span class="token number">2</span>?routing=fox2
<span class="token punctuation">{</span>
 <span class="token property">&quot;content&quot;</span><span class="token operator">:</span><span class="token string">&quot;elasticsearch Search&quot;</span>
<span class="token punctuation">}</span>

POST /blogs/_doc/<span class="token number">3</span>?routing=fox3
<span class="token punctuation">{</span>
 <span class="token property">&quot;content&quot;</span><span class="token operator">:</span><span class="token string">&quot;elasticsearch&quot;</span>
<span class="token punctuation">}</span>

GET /blogs/_search
<span class="token punctuation">{</span>
  <span class="token property">&quot;query&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">&quot;match&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token property">&quot;content&quot;</span><span class="token operator">:</span> <span class="token string">&quot;elasticsearch&quot;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

#解决算分不准的问题
GET /blogs/_search?search_type=dfs_query_then_fetch
<span class="token punctuation">{</span>
  <span class="token property">&quot;query&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">&quot;match&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token property">&quot;content&quot;</span><span class="token operator">:</span> <span class="token string">&quot;elasticsearch&quot;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>解决算分不准的方法：</p><ul><li><p>数据量不大的时候，可以将主分片数设置为1。当数据量足够大时候，只要保证文档均匀分散在各个分片上，结果一般就不会出现偏差</p></li><li><p>使用DFS Query Then Fetch</p></li><li><ul><li>搜索的URL中指定参数“_search?search_type=dfs_query_then_fetch&quot;</li><li>到每个分片把各分片的词频和文档频率进行搜集，然后完整的进行一次相关性算分,</li></ul></li></ul><p>耗费更加多的CPU和内存，执行性能低下，—般不建议使用</p><h3 id="如何设计分片数" tabindex="-1"><a class="header-anchor" href="#如何设计分片数" aria-hidden="true">#</a> 如何设计分片数</h3><p>当分片数&gt;节点数时</p><ul><li>一旦集群中有新的数据节点加入，分片就可以自动进行分配</li><li>分片在重新分配时，系统不会有downtime</li></ul><p>多分片的好处: 一个索引如果分布在不同的节点，多个节点可以并行执行</p><ul><li>查询可以并行执行</li><li>数据写入可以分散到多个机器</li></ul><p><strong>案例1</strong></p><ul><li>每天1GB的数据，一个索引一个主分片，一个副本分片</li><li>需保留半年的数据，接近360 GB的数据量，360个分片</li></ul><p><strong>案例2</strong></p><ul><li>5个不同的日志，每天创建一个日志索引。每个日志索引创建10个主分片</li><li>保留半年的数据</li><li>5<em>10</em> 30* 6 = 9000个分片</li></ul><p><strong>分片过多所带来的副作用</strong></p><p>Shard是Elasticsearch 实现集群水平扩展的最小单位。过多设置分片数会带来一些潜在的问题：</p><ul><li>每个分片是一个Lucene的索引，会使用机器的资源。过多的分片会导致额外的性能开销。</li><li>每次搜索的请求,需要从每个分片上获取数据</li><li>分片的Meta 信息由Master节点维护。过多，会增加管理的负担。经验值，控制分片总数在10W以内</li></ul><h3 id="如何确定主分片数" tabindex="-1"><a class="header-anchor" href="#如何确定主分片数" aria-hidden="true">#</a> 如何确定主分片数</h3><p>从存储的物理角度看：</p><ul><li>搜索类应用，单个分片不要超过20 GB</li><li>日志类应用，单个分片不要大于50 GB</li></ul><p>为什么要控制分片存储大小：</p><ul><li>提高Update 的性能</li><li>进行Merge 时，减少所需的资源</li><li>丢失节点后，具备更快的恢复速度</li><li>便于分片在集群内 Rebalancing</li></ul><h3 id="如何确定副本分片数" tabindex="-1"><a class="header-anchor" href="#如何确定副本分片数" aria-hidden="true">#</a> 如何确定副本分片数</h3><p>副本是主分片的拷贝：</p><ul><li>提高系统可用性︰响应查询请求，防止数据丢失</li><li>需要占用和主分片一样的资源</li></ul><p>对性能的影响：</p><ul><li>副本会降低数据的索引速度: 有几份副本就会有几倍的CPU资源消耗在索引上</li><li>会减缓对主分片的查询压力，但是会消耗同样的内存资源。如果机器资源充分，提高副本数，可以提高整体的查询QPS</li></ul><p>ES的分片策略会尽量保证节点上的分片数大致相同，但是有些场景下会导致分配不均匀：</p><ul><li>扩容的新节点没有数据，导致新索引集中在新的节点</li><li>热点数据过于集中，可能会产生性能问题</li></ul><p>可以通过调整分片总数，避免分配不均衡</p><ul><li>&quot;index.routing.allocation.total_shards_per_node&quot;，index级别的，表示这个index每个Node总共允许存在多少个shard，默认值是-1表示无穷多个；</li><li>&quot;cluster.routing.allocation.total_shards_per_node&quot;，cluster级别，表示集群范围内每个Node允许存在有多少个shard。默认值是-1表示无穷多个。</li></ul><p>如果目标Node的Shard数超过了配置的上限，则不允许分配Shard到该Node上。注意：index级别的配置会覆盖cluster级别的配置。</p><p>思考：5个节点的集群。索引有5个主分片，1个副本，index.routing.allocation.total_shards_per_node应该如何设置?</p><ul><li>(5+5)/ 5= 2</li><li>生产环境中要适当调大这个数字，避免有节点下线时，分片无法正常迁移</li></ul><h2 id="es底层读写工作原理" tabindex="-1"><a class="header-anchor" href="#es底层读写工作原理" aria-hidden="true">#</a> ES底层读写工作原理</h2><p>写请求是写入 primary shard，然后同步给所有的 replica shard；读请求可以从 primary shard 或 replica shard 读取，采用的是随机轮询算法。</p><h3 id="es写入数据的过程" tabindex="-1"><a class="header-anchor" href="#es写入数据的过程" aria-hidden="true">#</a> ES写入数据的过程</h3><ol><li>客户端选择一个node发送请求过去，这个node就是coordinating node (协调节点)</li><li>coordinating node，对document进行路由，将请求转发给对应的node</li><li>node上的primary shard处理请求，然后将数据同步到replica node</li><li>coordinating node如果发现primary node和所有的replica node都搞定之后，就会返回请求到客户端</li></ol><p>​ <img src="https://img.jssjqd.cn//202305022228378.png" alt="image-20230502222857651" loading="lazy"></p><h3 id="es读取数据的过程" tabindex="-1"><a class="header-anchor" href="#es读取数据的过程" aria-hidden="true">#</a> ES读取数据的过程</h3><p><strong>根据id查询数据的过程</strong></p><p>根据 doc id 进行 hash，判断出来当时把 doc id 分配到了哪个 shard 上面去，从那个 shard 去查询。</p><ol><li>客户端发送请求到任意一个 node，成为 coordinate node 。</li><li>coordinate node 对 doc id 进行哈希路由，将请求转发到对应的 node，此时会使用 round-robin 随机轮询算法，在 primary shard 以及其所有 replica 中随机选择一个，让读请求负载均衡。</li><li>接收请求的 node 返回 document 给 coordinate node 。</li><li>coordinate node 返回 document 给客户端。</li></ol><p><strong>根据关键词查询数据的过程</strong></p><ul><li>客户端发送请求到一个 coordinate node 。</li><li>协调节点将搜索请求转发到所有的 shard 对应的 primary shard 或 replica shard ，都可以。</li><li>query phase：每个 shard 将自己的搜索结果返回给协调节点，由协调节点进行数据的合并、排序、分页等操作，产出最终结果。</li><li>fetch phase：接着由协调节点根据 doc id 去各个节点上拉取实际的 document 数据，最终返回给客户端。</li></ul><h3 id="写数据底层原理" tabindex="-1"><a class="header-anchor" href="#写数据底层原理" aria-hidden="true">#</a> 写数据底层原理</h3><p><strong>核心概念</strong></p><p><strong>segment file</strong>: 存储倒排索引的文件，每个segment本质上就是一个倒排索引，每秒都会生成一个segment文件，当文件过多时es会自动进行segment merge（合并文件），合并时会同时将已经标注删除的文档物理删除。</p><p><strong>commit point</strong>: 记录当前所有可用的segment，每个commit point都会维护一个.del文件，即每个.del文件都有一个commit point文件（es删除数据本质是不属于物理删除），当es做删改操作时首先会在.del文件中声明某个document已经被删除，文件内记录了在某个segment内某个文档已经被删除，当查询请求过来时在segment中被删除的文件是能够查出来的，但是当返回结果时会根据commit point维护的那个.del文件把已经删除的文档过滤掉</p><p><strong>translog日志文件</strong>: 为了防止elasticsearch宕机造成数据丢失保证可靠存储，es会将每次写入数据同时写到translog日志中。</p><p>**os cache：**操作系统里面，磁盘文件其实都有一个东西，叫做os cache，操作系统缓存，就是说数据写入磁盘文件之前，会先进入os cache，先进入操作系统级别的一个内存缓存中去</p><p>​ <img src="https://img.jssjqd.cn//202305022229339.png" alt="image-20230502222903316" loading="lazy"></p><p><strong>Refresh</strong></p><ul><li>将文档先保存在Index buffer中，以refresh_interval为间隔时间，定期清空buffer，生成 segment,借助文件系统缓存的特性，先将segment放在文件系统缓存中，并开放查询，以提升搜索的实时性</li></ul><p><strong>Translog</strong></p><ul><li>Segment没有写入磁盘，即便发生了当机，重启后，数据也能恢复，从ES6.0开始默认配置是每次请求都会落盘</li></ul><p><strong>Flush</strong></p><ul><li>删除旧的translog 文件</li><li>生成Segment并写入磁盘│更新commit point并写入磁盘。ES自动完成，可优化点不多</li></ul><h2 id="如何提升集群的读写性能" tabindex="-1"><a class="header-anchor" href="#如何提升集群的读写性能" aria-hidden="true">#</a> 如何提升集群的读写性能</h2><h3 id="提升集群读取性能的方法" tabindex="-1"><a class="header-anchor" href="#提升集群读取性能的方法" aria-hidden="true">#</a> 提升集群读取性能的方法</h3><p><strong>数据建模</strong></p><ul><li>尽量将数据先行计算，然后保存到Elasticsearch 中。尽量避免查询时的 Script计算</li></ul><div class="language-post line-numbers-mode" data-ext="post"><pre class="language-post"><code>#避免查询时脚本
GET blogs/_search
{
  &quot;query&quot;: {
    &quot;bool&quot;: {
      &quot;must&quot;: [
        {&quot;match&quot;: {
          &quot;title&quot;: &quot;elasticsearch&quot;
        }}
      ],
      
      &quot;filter&quot;: {
        &quot;script&quot;: {
          &quot;script&quot;: {
            &quot;source&quot;: &quot;doc[&#39;title.keyword&#39;].value.length()&gt;5&quot;
          }
        }
      }
    }
  }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>尽量使用Filter Context，利用缓存机制，减少不必要的算分</li><li>结合profile，explain API分析慢查询的问题，持续优化数据模型</li><li>避免使用*开头的通配符查询</li></ul><div class="language-json line-numbers-mode" data-ext="json"><pre class="language-json"><code>GET /es_db/_search
<span class="token punctuation">{</span>
  <span class="token property">&quot;query&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">&quot;wildcard&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token property">&quot;address&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token property">&quot;value&quot;</span><span class="token operator">:</span> <span class="token string">&quot;*白云*&quot;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>优化分片</strong></p><ul><li><p>避免Over Sharing</p></li><li><ul><li>一个查询需要访问每一个分片，分片过多，会导致不必要的查询开销</li></ul></li><li><p>结合应用场景，控制单个分片的大小</p></li><li><ul><li>Search: 20GB</li><li>Logging: 40GB</li></ul></li><li><p>Force-merge Read-only索引</p></li><li><ul><li>使用基于时间序列的索引，将只读的索引进行force merge，减少segment数量</li></ul></li></ul><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment">#手动force merge</span>
POST /my_index/_forcemerge
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="提升写入性能的方法" tabindex="-1"><a class="header-anchor" href="#提升写入性能的方法" aria-hidden="true">#</a> 提升写入性能的方法</h3><ul><li><p>写性能优化的目标: 增大写吞吐量，越高越好</p></li><li><p>客户端: 多线程，批量写</p></li><li><ul><li>可以通过性能测试，确定最佳文档数量</li><li>多线程: 需要观察是否有HTTP 429（Too Many Requests）返回，实现 Retry以及线程数量的自动调节</li></ul></li><li><p>服务器端: 单个性能问题，往往是多个因素造成的。需要先分解问题，在单个节点上进行调整并且结合测试，尽可能压榨硬件资源,以达到最高吞吐量</p></li><li><ul><li>使用更好的硬件。观察CPU / IO Block</li><li>线程切换│堆栈状况</li></ul></li></ul><p><strong>服务器端优化写入性能的一些手段</strong></p><ul><li><p>降低IO操作</p></li><li><ul><li>使用ES自动生成的文档ld</li><li>一些相关的ES 配置，如Refresh Interval</li></ul></li><li><p>降低 CPU 和存储开销</p></li><li><ul><li>减少不必要分词</li><li>避免不需要旳doc_values</li><li>文档的字段尽量保证相同的顺予，可以提高文档的压缩率</li></ul></li><li><p>尽可能做到写入和分片的均衡负载，实现水平扩展</p></li><li><ul><li>Shard Filtering / Write Load Balancer</li></ul></li><li><p>调整Bulk 线程池和队列</p></li></ul><p>注意：ES 的默认设置，已经综合考虑了数据可靠性，搜索的实时性，写入速度，一般不要盲目修改。一切优化，都要基于高质量的数据建模。</p><p><strong>建模时的优化</strong></p><ul><li>只需要聚合不需要搜索，index设置成false</li><li>不要对字符串使用默认的dynamic mapping。字段数量过多，会对性能产生比较大的影响</li><li>Index_options控制在创建倒排索引时，哪些内容会被添加到倒排索引中。</li></ul><p>如果需要追求极致的写入速度，可以牺牲数据可靠性及搜索实时性以换取性能：</p><ul><li>牺牲可靠性: 将副本分片设置为0，写入完毕再调整回去</li><li>牺牲搜索实时性︰增加Refresh Interval的时间</li><li>牺牲可靠性: 修改Translog的配置</li></ul><p><strong>降低 Refresh的频率</strong></p><ul><li><p>增加refresh_interval 的数值。默认为1s ，如果设置成-1，会禁止自动refresh</p></li><li><ul><li>避免过于频繁的refresh，而生成过多的segment 文件</li><li>但是会降低搜索的实时性</li></ul></li></ul><p>​ PUT /my_index/_settings { &quot;index&quot; : { &quot;refresh_interval&quot; : &quot;10s&quot; } }</p><ul><li><p>增大静态配置参数indices.memory.index_buffer_size</p></li><li><ul><li>默认是10%，会导致自动触发refresh</li></ul></li></ul><p><strong>降低Translog写磁盘的频率，但是会降低容灾能力</strong></p><ul><li>Index.translog.durability: 默认是request，每个请求都落盘。设置成async，异步写入</li><li>lndex.translog.sync_interval：设置为60s，每分钟执行一次</li><li>Index.translog.flush_threshod_size: 默认512 m，可以适当调大。当translog 超过该值，会触发flush</li></ul><p><strong>分片设定</strong></p><ul><li>副本在写入时设为0，完成后再增加</li><li>合理设置主分片数，确保均匀分配在所有数据节点上</li><li>Index.routing.allocation.total_share_per_node:限定每个索引在每个节点上可分配的主分片数</li></ul><p><strong>调整Bulk 线程池和队列</strong></p>`,188),V=n("li",null,[n("p",null,"客户端")],-1),J=n("li",null,[n("ul",null,[n("li",null,"单个bulk请求体的数据量不要太大，官方建议大约5-15m"),n("li",null,"写入端的 bulk请求超时需要足够长，建议60s 以上"),n("li",null,"写入端尽量将数据轮询打到不同节点。")])],-1),K=n("li",null,[n("p",null,"服务器端")],-1),Q=n("li",null,"索引创建属于计算密集型任务，应该使用固定大小的线程池来配置。来不及处理的放入队列，线程数应该配置成CPU核心数+1，避免过多的上下文切换",-1),X=n("li",null,"队列大小可以适当增加，不要过大，否则占用的内存会成为GC的负担",-1),Y={href:"https://blog.csdn.net/justlpf/article/details/103233215",target:"_blank",rel:"noopener noreferrer"},Z=l(`<div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>DELETE myindex
PUT myindex
{
  &quot;settings&quot;: {
    &quot;index&quot;: {
      &quot;refresh_interval&quot;: &quot;30s&quot;,  #30s一次refresh
      &quot;number_of_shards&quot;: &quot;2&quot;
    },
    &quot;routing&quot;: {
      &quot;allocation&quot;: {
        &quot;total_shards_per_node&quot;: &quot;3&quot;  #控制分片，避免数据热点
      }
    },
    &quot;translog&quot;: {
      &quot;sync_interval&quot;: &quot;30s&quot;,
      &quot;durability&quot;: &quot;async&quot;    #降低translog落盘频率
    },
    &quot;number_of_replicas&quot;: 0
  },
  &quot;mappings&quot;: {
    &quot;dynamic&quot;: false,     #避免不必要的字段索引，必要时可以通过update by query
索引必要的字段
    &quot;properties&quot;: {}
  }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>​</p>`,2);function $(nn,sn){const a=t("ExternalLinkIcon");return o(),p("div",null,[c,n("p",null,[n("a",u,[s("http://192.168.65.174:9200/_cat/nodes?pretty"),e(a)])]),d,m,v,k,b,n("p",null,[s("项目网址："),n("a",g,[s("https://github.com/lmenezes/cerebro"),e(a)])]),h,n("p",null,[s("下载地址："),n("a",q,[s("https://github.com/lmenezes/cerebro/releases/download/v0.9.4/cerebro-0.9.4.zip"),e(a)])]),_,n("p",null,[s("访问："),n("a",y,[s("http://192.168.65.174:9000/"),e(a)])]),f,n("p",null,[s("输入ES集群节点："),n("a",x,[s("http://192.168.65.192:9200"),e(a)]),s("，建立连接：")]),E,n("p",null,[S,s(),n("a",j,[T,e(a)])]),C,n("p",null,[s("参考文档："),n("a",P,[s("https://www.elastic.co/guide/en/elasticsearch/reference/7.17/configuring-stack-security.html"),e(a)])]),w,N,M,n("ul",null,[G,z,n("li",null,[n("ul",null,[n("li",null,[s("Search Guard ： "),n("a",B,[s("https://search-guard.com/"),e(a)])]),n("li",null,[s("readonlyrest： "),n("a",U,[s("https://readonlyrest.com/"),e(a)])])])]),D,A]),I,n("p",null,[s("浏览器访问"),n("a",R,[s("http://192.168.65.174:9200/需要输入用户名密码"),e(a)])]),O,n("p",null,[n("a",L,[s("https://www.elastic.co/guide/en/elasticsearch/reference/7.17/ccr-apis.html"),e(a)])]),F,H,W,n("ul",null,[V,J,K,n("li",null,[n("ul",null,[Q,X,n("li",null,[s("ES线程池设置： "),n("a",Y,[s("https://blog.csdn.net/justlpf/article/details/103233215"),e(a)])])])])]),Z])}const ln=i(r,[["render",$],["__file","index.html.vue"]]);export{ln as default};
