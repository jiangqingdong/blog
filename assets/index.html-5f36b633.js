import{_ as p}from"./plugin-vue_export-helper-c27b6911.js";import{r as t,o as i,c as o,a,b as n,e as l,f as s}from"./app-c8395efa.js";const r={},d=s('<h2 id="分布式唯一id实战" tabindex="-1"><a class="header-anchor" href="#分布式唯一id实战" aria-hidden="true">#</a> 分布式唯一ID实战</h2><p><strong>背景</strong></p><p>日常开发中，我们需要对系统中的各种数据使用 ID 唯一表示，比如用户 ID 对应且仅对应一个人，商品 ID 对应且仅对应一件商品，订单 ID 对应且仅对应一个订单。我们现实生活中也有各种 ID，比如身份证 ID 对应且仅对应一个人，简单来说，ID 就是数据的唯一标识。</p><p>一般情况下，会使用数据库的自增主键作为数据ID，但是在大数量的情况下，我们往往会引入分布式、分库分表等手段来应对，很明显对数据分库分表后我们依然需要有一个唯一ID来标识一条数据或消息，数据库的自增ID已经无法满足需求。此时一个能够生成全局唯一ID的系统是非常必要的。概括下来，那业务系统对ID号的要求有哪些呢？</p><p><strong>全局唯一性</strong>：不能出现重复的ID号，既然是唯一标识，这是最基本的要求。</p><p><strong>趋势递增</strong>、<strong>单调递增</strong>：保证下一个ID一定大于上一个ID。</p><p><strong>信息安全</strong>：如果ID是连续的，恶意用户的扒取工作就非常容易做了，直接按照顺序下载指定URL即可；如果是订单号就更危险了，竞争对手可以直接知道我们一天的单量。所以在一些应用场景下，会需要ID无规则、不规则。</p><p>同时除了对ID号码自身的要求，业务还对ID号生成系统的可用性要求极高，想象一下，如果ID生成系统不稳定，大量依赖ID生成系统，比如订单生成等关键动作都无法执行。所以一个ID生成系统还需要做到平均延迟和TP999延迟都要尽可能低；可用性5个9；高QPS。</p><h2 id="常见方法介绍" tabindex="-1"><a class="header-anchor" href="#常见方法介绍" aria-hidden="true">#</a> 常见方法介绍</h2><h3 id="uuid" tabindex="-1"><a class="header-anchor" href="#uuid" aria-hidden="true">#</a> UUID</h3><p>UUID(Universally Unique Identifier)的标准型式包含32个16进制数字，以连字号分为五段，形式为8-4-4-4-12的36个字符，示例：550e8400-e29b-41d4-a716-446655440000，到目前为止业界一共有5种方式生成UUID，详情见IETF发布的UUID规范 A Universally Unique IDentifier (UUID) URN Namespace。</p><p><strong>优点</strong>：</p><ul><li>性能非常高：本地生成，没有网络消耗。</li></ul><p><strong>缺点</strong>：</p><ul><li>不易于存储：UUID太长，16字节128位，通常以36长度的字符串表示，很多场景不适用。</li><li>信息不安全：基于MAC地址生成UUID的算法可能会造成MAC地址泄露，这个漏洞曾被用于寻找梅丽莎病毒的制作者位置。</li></ul><p>ID作为主键时在特定的环境会存在一些问题，比如做DB主键的场景下，UUID就非常不适用：</p><ul><li>MySQL官方有明确的建议主键要尽量越短越好[4]，36个字符长度的UUID不符合要求。</li><li>对MySQL索引不利：如果作为数据库主键，在InnoDB引擎下，UUID的无序性可能会引起数据位置频繁变动，严重影响性能。在MySQL InnoDB引擎中使用的是聚集索引，由于多数RDBMS使用B-tree的数据结构来存储索引数据，在主键的选择上面我们应该尽量使用有序的主键保证写入性能。</li></ul><p>可以直接使用jdk自带的UUID，原始生成的是带中划线的，如果不需要，可自行去除</p><p>​ <img src="https://img.jssjqd.cn//202305022238343.png" alt="image-20230502223827082" loading="lazy"></p><h3 id="雪花算法及其衍生" tabindex="-1"><a class="header-anchor" href="#雪花算法及其衍生" aria-hidden="true">#</a> 雪花算法及其衍生</h3><p>这种方案大致来说是一种以划分命名空间（UUID也算，由于比较常见，所以单独分析）来生成ID的一种算法，Snowflake 是 Twitter 开源的分布式 ID 生成算法。Snowflake 把64-bit分别划分成多段，分开来标示机器、时间等，比如在snowflake中的64-bit分别表示如下图所示：</p><p>​ <img src="https://img.jssjqd.cn//202305022238361.png" alt="image-20230502223830395" loading="lazy"></p><p>第 0 位： 符号位（标识正负），始终为 0，没有用，不用管。</p><p>第 1~41 位 ：一共 41 位，用来表示时间戳，单位是毫秒，可以支撑 2 ^41 毫秒（约 69 年）</p><p>第 42~52 位 ：一共 10 位，一般来说，前 5 位表示机房 ID，后 5 位表示机器 ID（实际项目中可以根据实际情况调整），这样就可以区分不同集群/机房的节点，这样就可以表示32个IDC，每个IDC下可以有32台机器。</p><p>第 53~64 位 ：一共 12 位，用来表示序列号。 序列号为自增值，代表单台机器每毫秒能够产生的最大 ID 数(2^12 = 4096),也就是说单台机器每毫秒最多可以生成 4096 个 唯一 ID。</p><p>理论上snowflake方案的QPS约为409.6w/s，这种分配方式可以保证在任何一个IDC的任何一台机器在任意毫秒内生成的ID都是不同的。</p>',27),c=a("strong",null,"美团的 Leaf、百度的 UidGenerator",-1),u={href:"https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md",target:"_blank",rel:"noopener noreferrer"},k=s(`<p>关于自行实现Snowflake 算法，可以参考<strong>tulingmall-unqid</strong>下的<strong>com.tuling.tulingmall.service.snowflake</strong>下的代码。</p><p><strong>Snowflake 优缺点是：</strong></p><p><strong>优点</strong>：</p><ul><li>毫秒数在高位，自增序列在低位，整个ID都是趋势递增的。</li><li>不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成ID的性能也是非常高的。</li><li>可以根据自身业务特性分配bit位，非常灵活。</li></ul><p><strong>缺点</strong>：</p><ul><li>强依赖机器时钟，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态。</li></ul><p>当然，在我们自己的项目如果不想自行实现唯一性ID，还可以利用外部中间件，比如Mongdb objectID，它也可以算作是和snowflake类似方法，通过“时间+机器码+pid+inc”共12个字节，通过4+3+2+3的方式最终标识成一个24长度的十六进制字符。</p><p>其次Seata内置了一个分布式UUID生成器，用于辅助生成全局事务ID和分支事务ID，我们同样可以拿来使用，完整类名为： <strong>io.seata.common.util.IdWorker</strong></p><h3 id="数据库生成" tabindex="-1"><a class="header-anchor" href="#数据库生成" aria-hidden="true">#</a> 数据库生成</h3><h4 id="mysql" tabindex="-1"><a class="header-anchor" href="#mysql" aria-hidden="true">#</a> MYSQL</h4><p>以MySQL举例，</p><p>1.创建一个数据库表。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">\`</span>sequence_id<span class="token punctuation">\`</span></span> <span class="token punctuation">(</span>

  <span class="token identifier"><span class="token punctuation">\`</span>id<span class="token punctuation">\`</span></span> <span class="token keyword">bigint</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">unsigned</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>

  <span class="token identifier"><span class="token punctuation">\`</span>stub<span class="token punctuation">\`</span></span> <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">&#39;&#39;</span><span class="token punctuation">,</span>

  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">\`</span>id<span class="token punctuation">\`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>

  <span class="token keyword">UNIQUE</span> <span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">\`</span>stub<span class="token punctuation">\`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">\`</span>stub<span class="token punctuation">\`</span></span><span class="token punctuation">)</span>

<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8mb4<span class="token punctuation">;</span>stub 字段无意义，只是为了占位，便于我们插入或者修改数据。并且，给 stub 字段创建了唯一索引，保证其唯一性。

<span class="token number">2.</span>通过 <span class="token keyword">replace</span> <span class="token keyword">into</span> 来插入数据。

<span class="token keyword">BEGIN</span><span class="token punctuation">;</span>

<span class="token keyword">REPLACE</span> <span class="token keyword">INTO</span> sequence_id <span class="token punctuation">(</span>stub<span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">&#39;stub&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">SELECT</span> LAST_INSERT_ID<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">COMMIT</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>插入数据这里，我们没有使用 insert into 而是使用 replace into 来插入数据。replace是insert的增强版，replace into 首先尝试插入数据到表中，1. 如果发现表中已经有此行数据（根据主键或者唯一索引判断）则先删除此行数据，然后插入新的数据。 2. 否则，直接插入新数据。</p><p>数据库方案的优缺点如下：</p><p><strong>优点</strong>：</p><ul><li>非常简单，利用现有数据库系统的功能实现，成本小，有DBA专业维护。ID号单调自增，存储消耗空间小。</li></ul><p><strong>缺点</strong>：</p><ul><li>支持的并发量不大</li><li>存在数据库单点问题（可以使用数据库集群解决，不过增加了复杂度）</li><li>ID 没有具体业务含义</li><li>安全问题（比如根据订单 ID 的递增规律就能推算出每天的订单量 ）</li><li>每次获取 ID 都要访问一次数据库（增加了对数据库的压力，获取速度也慢）</li></ul><p>对于MySQL性能问题，可用如下方案解决：在分布式系统中我们可以多部署几台机器，每台机器设置不同的初始值，且步长和机器数相等。比如有两台机器。设置步长step为2，TicketServer1的初始值为1（1，3，5，7，9，11…）、TicketServer2的初始值为2（2，4，6，8，10…）。这是Flickr（雅虎旗下图片分享网站）团队在2010年撰文介绍的一种主键生成策略（Ticket Servers: Distributed Unique Primary Keys on the Cheap ）。为了实现上述方案分别设置两台机器对应的参数，TicketServer1从1开始发号，TicketServer2从2开始发号，两台机器每次发号之后都递增2。</p><p>假设我们要部署N台机器，步长需设置为N，每台的初始值依次为0,1,2…N-1。</p><p>这种架构貌似能够满足性能的需求，但有以下几个缺点：</p><p>系统水平扩展比较困难，比如定义好了步长和机器台数之后，如果要添加机器该怎么做？假设现在只有一台机器发号是1,2,3,4,5（步长是1），这个时候需要扩容机器一台。可以这样做：把第二台机器的初始值设置得比第一台超过很多，比如140（假设在扩容时间之内第一台不可能发到140），同时设置步长为2，那么这台机器下发的号码都是140以后的偶数。然后摘掉第一台，把ID值保留为奇数，比如7，然后修改第一台的步长为2。让它符合我们定义的号段标准，对于这个例子来说就是让第一台以后只能产生奇数。扩容方案看起来复杂吗？貌似还好，现在想象一下如果我们线上有100台机器，这个时候要扩容该怎么做？简直是噩梦。所以系统水平扩展方案复杂难以实现。</p><p>ID没有了单调递增的特性，只能趋势递增，这个缺点对于一般业务需求不是很重要，可以容忍。</p><p>数据库压力还是很大，每次获取ID都得读写一次数据库，只能靠堆机器来提高性能。</p><h4 id="redis" tabindex="-1"><a class="header-anchor" href="#redis" aria-hidden="true">#</a> Redis</h4><p>通过 Redis 的 incr 命令即可实现对 id 原子顺序递增，例如：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> incr sequence_id_biz_type

<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为了提高可用性和并发，我们可以使用 Redis Cluster。</p><p>除了高可用和并发之外，我们知道 Redis 基于内存，我们需要持久化数据，避免重启机器或者机器故障后数据丢失。很明显，Redis方案性能很好并且生成的 ID 是有序递增的。</p><p>不过，我们也知道，即使Redis 开启了持久化，不管是快照（snapshotting，RDB）、只追加文件（append-only file, AOF）还是 RDB 和 AOF 的混合持久化依然存在着丢失数据的可能，那就意味着产生的ID存在着重复的概率。</p><h2 id="分布式id微服务" tabindex="-1"><a class="header-anchor" href="#分布式id微服务" aria-hidden="true">#</a> 分布式ID微服务</h2><p>从上面的分析可以看出，每种方案都各有优劣，在我们的商城系统中则基于美团的Leaf实现了自己的分布式ID微服务。我们先来看看美团Leaf方案。</p><h3 id="美团leaf方案实现" tabindex="-1"><a class="header-anchor" href="#美团leaf方案实现" aria-hidden="true">#</a> 美团Leaf方案实现</h3><p>Leaf这个名字是来自德国哲学家、数学家莱布尼茨的一句话： There are no two identical leaves in the world（“世界上没有两片相同的树叶”）</p><p>Leaf分别在MySQL和雪花上做了相应的优化，实现了Leaf-segment和Leaf-snowflake方案。</p><h4 id="leaf-segment数据库方案" tabindex="-1"><a class="header-anchor" href="#leaf-segment数据库方案" aria-hidden="true">#</a> Leaf-segment数据库方案</h4><p>Leaf-segment方案，在使用数据库的方案上，做了如下改变：</p><p>原MySQL方案每次获取ID都得读写一次数据库，造成数据库压力大。改为批量获取，每次获取一个segment(step决定大小)号段的值。用完之后再去数据库获取新的号段，可以大大的减轻数据库的压力。</p><p>各个业务不同的发号需求用biz_tag字段来区分，每个biz-tag的ID获取相互隔离，互不影响。如果以后有性能需求需要对数据库扩容，不需要上述描述的复杂的扩容操作，只需要对biz_tag分库分表就行。</p><p>数据库表设计如下：</p><p>​ <img src="https://img.jssjqd.cn//202305022239194.png" alt="image-20230502223904883" loading="lazy"></p><p>重要字段说明：biz_tag用来区分业务，max_id表示该biz_tag目前所被分配的ID号段的最大值，step表示每次分配的号段长度。原来获取ID每次都需要写数据库，现在只需要把step设置得足够大，比如1000。那么只有当1000个号被消耗完了之后才会去重新读写一次数据库。读写数据库的频率从1减小到了1/step。</p><p>例如现在有3台机器，每台机器各取1000个，很明显在第一台Leaf机器上是1<sub>1000的号段，当这个号段用完时，会去加载另一个长度为step=1000的号段，假设另外两台号段都没有更新，这个时候第一台机器新加载的号段就应该是3001</sub>4000。同时数据库对应的biz_tag这条数据的max_id会从3000被更新成4000，更新号段的SQL语句如下：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">Begin</span>

<span class="token keyword">UPDATE</span> <span class="token keyword">table</span> <span class="token keyword">SET</span> max_id<span class="token operator">=</span>max_id<span class="token operator">+</span>step <span class="token keyword">WHERE</span> biz_tag<span class="token operator">=</span>xxx

<span class="token keyword">SELECT</span> tag<span class="token punctuation">,</span> max_id<span class="token punctuation">,</span> step <span class="token keyword">FROM</span> <span class="token keyword">table</span> <span class="token keyword">WHERE</span> biz_tag<span class="token operator">=</span>xxx

<span class="token keyword">Commit</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种模式有以下优缺点：</p><p><strong>优点</strong>：</p><ul><li>Leaf服务可以很方便的线性扩展，性能完全能够支撑大多数业务场景。</li><li>ID号码是趋势递增的8byte的64位数字，满足上述数据库存储的主键要求。</li><li>容灾性高：Leaf服务内部有号段缓存，即使DB宕机，短时间内Leaf仍能正常对外提供服务。</li><li>可以自定义max_id的大小，非常方便业务从原有的ID方式上迁移过来。</li></ul><p><strong>缺点</strong>：</p><ul><li>ID号码不够随机，能够泄露发号数量的信息，不太安全。</li><li>TP999数据波动大，当号段使用完之后还是会在获取新号段时在更新数据库的I/O依然会存在着等待，tg999数据会出现偶尔的尖刺。</li><li>DB宕机会造成整个系统不可用。</li></ul><h5 id="双buffer优化" tabindex="-1"><a class="header-anchor" href="#双buffer优化" aria-hidden="true">#</a> 双buffer优化</h5><p>对于第二个缺点，Leaf-segment做了一些优化，简单的说就是：</p><p>Leaf 取号段的时机是在号段消耗完的时候进行的，也就意味着号段临界点的ID下发时间取决于下一次从DB取回号段的时间，并且在这期间进来的请求也会因为DB号段没有取回来，导致线程阻塞。如果请求DB的网络和DB的性能稳定，这种情况对系统的影响是不大的，但是假如取DB的时候网络发生抖动，或者DB发生慢查询就会导致整个系统的响应时间变慢。</p><p>为此，希望DB取号段的过程能够做到无阻塞，不需要在DB取号段的时候阻塞请求线程，即当号段消费到某个点时就异步的把下一个号段加载到内存中。而不需要等到号段用尽的时候才去更新号段。这样做就可以很大程度上的降低系统的TP999指标。</p><p>采用双buffer的方式，Leaf服务内部有两个号段缓存区segment。当前号段已下发10%时，如果下一个号段未更新，则另启一个更新线程去更新下一个号段。当前号段全部下发完后，如果下个号段准备好了则切换到下个号段为当前segment接着下发，循环往复。</p><p>通常推荐segment长度设置为服务高峰期发号QPS的600倍（10分钟），这样即使DB宕机，Leaf仍能持续发号10-20分钟不受影响。</p><p>每次请求来临时都会判断下个号段的状态，从而更新此号段，所以偶尔的网络抖动不会影响下个号段的更新。</p><h5 id="leaf高可用容灾" tabindex="-1"><a class="header-anchor" href="#leaf高可用容灾" aria-hidden="true">#</a> Leaf高可用容灾</h5><p>对于第三点“DB可用性”问题，可以采用一主两从的方式，同时分机房部署，Master和Slave之间采用半同步方式同步数据。美团内部使用了奇虎360的Atlas数据库中间件（已开源，改名为DBProxy）做主从切换。当然这种方案在一些情况会退化成异步模式，甚至在非常极端情况下仍然会造成数据不一致的情况，但是出现的概率非常小。如果要保证100%的数据强一致，可以选择使用“类Paxos算法”实现的强一致MySQL方案，如MySQL 5.7中的MySQL Group Replication。但是运维成本和精力都会相应的增加，根据实际情况选型即可。</p><h4 id="leaf-snowflake方案" tabindex="-1"><a class="header-anchor" href="#leaf-snowflake方案" aria-hidden="true">#</a> Leaf-snowflake方案</h4><p>Leaf-segment方案可以生成趋势递增的ID，同时ID号是可计算的，不适用于订单ID生成场景，比如竞争对手在两天中午12点分别下单，通过订单id号相减就能大致计算出公司一天的订单量，这个是不能忍受的。面对这一问题，美团提供了 Leaf-snowflake方案。</p><p>Leaf-snowflake方案完全沿用snowflake方案的bit位设计，即是“1+41+10+12”的方式组装ID号。对于workerID的分配，当服务集群数量较小的情况下，完全可以手动配置。Leaf服务规模较大，动手配置成本太高。所以使用Zookeeper持久顺序节点的特性自动对snowflake节点配置wokerID。Leaf-snowflake是按照下面几个步骤启动的：</p><p>启动Leaf-snowflake服务，连接Zookeeper，在leaf_forever父节点下检查自己是否已经注册过（是否有该顺序子节点）。</p><p>如果有注册过直接取回自己的workerID（zk顺序节点生成的int类型ID号），启动服务。</p><p>如果没有注册过，就在该父节点下面创建一个持久顺序节点，创建成功后取回顺序号当做自己的workerID号，启动服务。</p><h5 id="弱依赖zookeeper" tabindex="-1"><a class="header-anchor" href="#弱依赖zookeeper" aria-hidden="true">#</a> 弱依赖ZooKeeper</h5><p>除了每次会去ZK拿数据以外，也会在本机文件系统上缓存一个workerID文件。当ZooKeeper出现问题，恰好机器出现问题需要重启时，能保证服务能够正常启动。这样做到了对三方组件的弱依赖。</p><h5 id="解决时钟问题" tabindex="-1"><a class="header-anchor" href="#解决时钟问题" aria-hidden="true">#</a> 解决时钟问题</h5><p>因为这种方案依赖时间，如果机器的时钟发生了回拨，那么就会有可能生成重复的ID号，需要解决时钟回退的问题。</p><p>首先在启动时，服务会进行检查：</p><p>1、新节点通过检查综合对比其余Leaf节点的系统时间来判断自身系统时间是否准确，具体做法是取所有运行中的Leaf-snowflake节点的服务IP：Port，然后通过RPC请求得到所有节点的系统时间，计算sum(time)/nodeSize，然后看本机时间与这个平均值是否在阈值之内来确定当前系统时间是否准确，准确正常启动服务，不准确认为本机系统时间发生大步长偏移，启动失败并报警。</p><p>2、在ZooKeeper 中登记过的老节点，同样会比较自身系统时间和ZooKeeper 上本节点曾经的记录时间以及所有运行中的Leaf-snowflake节点的时间，不准确同样启动失败并报警。</p><p>另外，在运行过程中，每隔一段时间节点都会上报自身系统时间写入ZooKeeper 。</p><p>​ <img src="https://img.jssjqd.cn//202305022239913.png" alt="image-20230502223922015" loading="lazy"></p><p>在服务运行过程中，机器的NTP同步也会造成秒级别的回退，由于强依赖时钟，对时间的要求比较敏感，美团建议有三种解决方案，一是可以直接关闭NTP同步；二是在时钟回拨的时候直接不提供服务直接返回ERROR_CODE，等时钟追上即可，三是做一层重试，然后上报报警系统，更或者是发现有时钟回拨之后自动摘除本身节点并报警，代码如下：</p><p>从美团的实际运行情况来看，在2017年闰秒出现那一次出现过部分机器回拨，由于Leaf-snowflake的策略保证，成功避免了对业务造成的影响。</p><h3 id="美团leaf现状" tabindex="-1"><a class="header-anchor" href="#美团leaf现状" aria-hidden="true">#</a> 美团Leaf现状</h3><p>Leaf在美团点评公司内部服务包含金融、支付交易、餐饮、外卖、酒店旅游、猫眼电影等众多业务线。目前Leaf的性能在4C8G的机器上QPS能压测到近5万/s，TP999 1ms，已经能够满足大部分的业务的需求。每天提供亿数量级的调用量。</p><p><strong>tulingmall-unqid实现</strong></p><p>从上面的分析可以看到，生成全局唯一ID的系统对于我们的项目来说是必须的，从诸多因素考虑，我们选用了美团的Leaf并根据项目的实际情况做了裁剪和改造。</p><p>首先，在我们的整个的商品系统中并没有安装Zookeeper而且也不考虑竞争对手，所以在<strong>tulingmall-unqid</strong>中完全去除了有关<strong>Leaf-snowflake</strong>的部分，从美团Leaf和我们的代码比较即可看出：</p><p>​ <img src="https://img.jssjqd.cn//202305022239143.png" alt="image-20230502223925699" loading="lazy"></p><p>其次，在美团Leaf的实现中，可以看到对外提供ID的方法</p><p>​ <img src="https://img.jssjqd.cn//202305022239031.png" alt="image-20230502223929830" loading="lazy"></p><p>很明显，一次只能提供一个ID，但是仔细考察商城系统的业务需求，比如订单，我们知道一个订单往往分为两个部分，订单的基本信息和订单详情，订单详情往往包含该订单的产品列表，在保存时我们往往也会用两张表来保存，一是订单表，二是订单详情表。订单表的ID很好说，每次从唯一ID服务取一个ID即可，但是订单详情表呢？我们会一次性插入一条订单记录和多条订单详情记录，如果对于订单详情记录的ID每次都从唯一ID服务取，这个无疑会对性能有影响，解决办法有两个：</p><p>1、订单详情记录的ID不保证全局唯一，依然使用数据库的自增主键；</p><p>2、订单详情记录的ID需要全局唯一，但并不每次从唯一ID服务，而是在生成订单时，一次性从唯一ID服务获得。</p><p>在我们的商城系统中，我们选择了第二种方式，很自然就需要对原来的美团Leaf进行改造：</p><p>​ <img src="https://img.jssjqd.cn//202305022239393.png" alt="image-20230502223933316" loading="lazy"></p><p>可以看到，我们新增了一个批量获得唯一ID的方法，并限定每次可以获得ID的最大数量为5000个。</p><p>我们的tulingmall-unqid本身是个无状态的服务，可以很方便的进行服务集群，以高伸缩性来应对服务的高可用、性能上的需求。</p>`,91);function g(h,D){const e=t("ExternalLinkIcon");return i(),o("div",null,[d,a("p",null,[n("有很多基于 Snowflake 算法的开源实现比如"),c,n("(自 18 年后，UidGenerator 就基本没有再维护了，"),a("a",u,[n("https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md"),l(e)]),n(")，并且这些开源实现对原有的 Snowflake 算法进行了优化。在实际项目中，我们一般也会对 Snowflake 算法进行改造，最常见的就是在算法生成的 ID 中加入业务类型信息。")]),k])}const I=p(r,[["render",g],["__file","index.html.vue"]]);export{I as default};
