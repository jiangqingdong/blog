import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{o as e,c as i,f as t}from"./app-c8395efa.js";const n={},s=t('<p><strong>概述</strong></p><p>我们的数据库一般都会并发执行多个事务，多个事务可能会并发的对相同的一批数据进行增删改查操作，可能就会导致我们说的脏写、脏读、不可重复读、幻读这些问题。</p><p>这些问题的本质都是数据库的多事务并发问题，为了解决多事务并发问题，数据库设计了<strong>事务隔离机制、锁机制、MVCC多版本并发控制隔离机制、日志机制</strong>，用一整套机制来<strong>解决多事务并发问题</strong>。接下来的，我们会深入讲解这些机制，让大家彻底理解数据库内部的执行原理。</p><h2 id="事务及其acid属性" tabindex="-1"><a class="header-anchor" href="#事务及其acid属性" aria-hidden="true">#</a> 事务及其ACID属性</h2><p>事务是一组操作要么全部成功，要么全部失败，目的是为了保证数据最终的一致性。</p><p>事务具有以下4个属性,通常简称为事务的ACID属性。</p><ul><li>原子性(Atomicity) ：当前事务的操作要么同时成功，要么同时失败。原子性由undo log日志来实现。</li><li>一致性(Consistent) ：使用事务的最终目的，由其它3个特性以及业务代码正确逻辑来实现。</li><li>隔离性(Isolation) ：在事务并发执行时，他们内部的操作不能互相干扰。隔离性由MySQL的各种锁以及MVCC机制来实现。</li><li>持久性(Durable) ：一旦提交了事务，它对数据库的改变就应该是永久性的。持久性由redo log日志来实现。</li></ul><h2 id="并发事务处理带来的问题" tabindex="-1"><a class="header-anchor" href="#并发事务处理带来的问题" aria-hidden="true">#</a> 并发事务处理带来的问题</h2><p><strong>更新丢失(Lost Update)或脏写</strong></p><p>当两个或多个事务选择同一行数据修改，有可能发生更新丢失问题，即最后的更新覆盖了由其他事务所做的更新。</p><p><strong>脏读（Dirty Reads）</strong></p><p>事务A读取到了事务B已经修改但尚未提交的数据</p><p><strong>不可重复读（Non-Repeatable Reads）</strong></p><p>事务A内部的相同查询语句在不同时刻读出的结果不一致</p><p><strong>幻读（Phantom Reads）</strong></p><p>幻读指的是事务A在前后两次查询同一个范围的时候，后一次查询看到了事务B新增的数据</p><h2 id="事务隔离级别" tabindex="-1"><a class="header-anchor" href="#事务隔离级别" aria-hidden="true">#</a> 事务隔离级别</h2><p>“脏读”、“不可重复读”和“幻读”,其实都是数据库读一致性问题,必须由数据库提供一定的事务隔离机制来解决。</p><table><thead><tr><th>隔离级别</th><th>脏读(Dirty Read)</th><th>不可重复读(NonRepeatable Read)</th><th>幻读(Phantom Read)</th></tr></thead><tbody><tr><td>读未提交(Read uncommitted)</td><td>可能</td><td>可能</td><td>可能</td></tr><tr><td>读已提交(Read committed)</td><td>不可能</td><td>可能</td><td>可能</td></tr><tr><td>可重复读(Repeatable read)</td><td>不可能</td><td>不可能</td><td>可能</td></tr><tr><td>可串行化(Serializable)</td><td>不可能</td><td>不可能</td><td>不可能</td></tr></tbody></table><p>数据库的事务隔离越严格,并发副作用越小,但付出的代价也就越大,因为事务隔离实质上就是使事务在一定程度上“串行化”进行,这显然与“并发”是矛盾的。</p><p>同时,不同的应用对读一致性和事务隔离程度的要求也是不同的,比如许多应用对“不可重复读&quot;和“幻读”并不敏感,可能更关心数据并发访问的能力。</p><p>查看当前数据库的事务隔离级别:</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>show variables like &#39;tx_isolation&#39;;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>设置事务隔离级别：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>set tx_isolation=&#39;REPEATABLE-READ&#39;;\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>Mysql默认的事务隔离级别是可重复读，用Spring开发程序时，如果不设置隔离级别默认用Mysql设置的隔离级别，如果Spring设置了就用已经设置的隔离级别</strong></p><p><strong>事务隔离级别案例分析</strong></p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>CREATE TABLE `account` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `name` varchar(255) DEFAULT NULL,\n  `balance` int(11) DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\nINSERT INTO `test`.`account` (`name`, `balance`) VALUES (&#39;lilei&#39;, &#39;450&#39;);\nINSERT INTO `test`.`account` (`name`, `balance`) VALUES (&#39;hanmei&#39;, &#39;16000&#39;);\nINSERT INTO `test`.`account` (`name`, `balance`) VALUES (&#39;lucy&#39;, &#39;2400&#39;);\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>读未提交：</strong></p><p>（1）打开一个客户端A，并设置当前事务模式为read uncommitted（未提交读），查询表account的初始值：</p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>set tx_isolation=&#39;read-uncommitted&#39;;              \n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>​ <img src="https://img.jssjqd.cn/202307041844585.png" alt="image-20230704184438798" loading="lazy"></p><p>（2）在客户端A的事务提交之前，打开另一个客户端B，更新表account：</p><p>​ <img src="https://img.jssjqd.cn/202307041844316.png" alt="image-20230704184445323" loading="lazy"></p><p>（3）这时，虽然客户端B的事务还没提交，但是客户端A就可以查询到B已经更新的数据：</p><p>​ <img src="https://img.jssjqd.cn/202307041844446.png" alt="image-20230704184448639" loading="lazy"></p><p>（4）一旦客户端B的事务因为某种原因回滚，所有的操作都将会被撤销，那客户端A查询到的数据其实就是<strong>脏数据</strong>：</p><p>​ <img src="https://img.jssjqd.cn/202307041844962.png" alt="image-20230704184453239" loading="lazy"></p><p>（5）在客户端A执行更新语句update account set balance = balance - 50 where id =1，lilei的balance没有变成350，居然是400，是不是很奇怪，数据不一致啊，如果你这么想就太天真了，在应用程序中，我们会用400-50=350，并不知道其他会话回滚了，要想解决这个问题可以采用读已提交的隔离级别</p><figure><img src="https://img.jssjqd.cn/202307041845803.png" alt="image-20230704184503938" tabindex="0" loading="lazy"><figcaption>image-20230704184503938</figcaption></figure><p><strong>3、读已提交</strong></p><p>（1）打开一个客户端A，并设置当前事务模式为read committed（未提交读），查询表account的所有记录：</p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>set tx_isolation=&#39;read-committed&#39;;              \n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>​ <img src="https://img.jssjqd.cn/202307041845963.png" alt="image-20230704184518045" loading="lazy"></p><p>（2）在客户端A的事务提交之前，打开另一个客户端B，更新表account：</p><p>​ <img src="https://img.jssjqd.cn/202307041845740.png" alt="image-20230704184525889" loading="lazy"></p><p>（3）这时，客户端B的事务还没提交，客户端A不能查询到B已经更新的数据，解决了脏读问题：</p><p>​ <img src="https://img.jssjqd.cn/202307041845994.png" alt="image-20230704184534768" loading="lazy"></p><p>（4）客户端B的事务提交</p><p>​ <img src="https://img.jssjqd.cn/202307041845400.png" alt="image-20230704184541607" loading="lazy"></p><p>（5）客户端A执行与上一步相同的查询，结果 与上一步不一致，即产生了不可重复读的问题</p><p>​ <img src="https://img.jssjqd.cn/202307041845836.png" alt="image-20230704184546822" loading="lazy"></p><p><strong>4、可重复读</strong></p><p>这个隔离级别记住一句话就能理解：可重复读隔离级别在事务开启的时候，第一次查询是查的数据库里已提交的最新数据，这时候全数据库会有一个快照(当然数据库并不是真正的生成了一个快照，这个快照机制怎么实现的后面课程会详细讲)，在这个事务之后执行的查询操作都是查快照里的数据，别的事务不管怎么修改数据对当前这个事务的查询都没有影响，但是当前事务如果修改了某条数据，那当前事务之后查这条修改的数据就是被修改之后的值，但是查其它数据依然是从快照里查，不受影响。</p><p>（1）打开一个客户端A，并设置当前事务模式为repeatable read，查询表account的所有记录</p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>set tx_isolation=&#39;repeatable-read&#39;;              \n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>​ <img src="https://img.jssjqd.cn/202307041847352.png" alt="image-20230704184710611" loading="lazy"></p><p>（2）在客户端A的事务提交之前，打开另一个客户端B，更新表account并提交</p><p>​ <img src="https://img.jssjqd.cn/202307041847824.png" alt="image-20230704184706900" loading="lazy"></p><p>（3）在客户端A查询表account的所有记录，与步骤（1）查询结果一致，没有出现不可重复读的问题</p><p>​ <img src="https://img.jssjqd.cn/202307041847238.png" alt="image-20230704184703346" loading="lazy"></p><p>（4）在客户端A，接着执行update account set balance = balance - 50 where id = 1，balance没有变成400-50=350，lilei的balance值用的是步骤2中的350来算的，所以是300，数据的一致性倒是没有被破坏。可重复读的隔离级别下使用了MVCC(multi-version concurrency control)机制，select操作是<strong>快照读（历史版本）</strong>；insert、update和delete是<strong>当前读（当前版本）</strong>。</p><p>​ <img src="https://img.jssjqd.cn/202307041846917.png" alt="image-20230704184658961" loading="lazy"></p><p>（5）重新打开客户端B，插入一条新数据后提交</p><p>​ <img src="https://img.jssjqd.cn/202307041846375.png" alt="image-20230704184654269" loading="lazy"></p><p>（6）在客户端A查询表account的所有记录，没有查出新增数据，所以没有出现幻读</p><p>​ <img src="https://img.jssjqd.cn/202307041846473.png" alt="image-20230704184649489" loading="lazy"></p><p>（7)验证幻读</p><p>在客户端A执行update account set balance=888 where id = 4；能更新成功，再次查询能查到客户端B新增的数据</p><p>​ <img src="https://img.jssjqd.cn/202307041846475.png" alt="image-20230704184645243" loading="lazy"></p><p><strong>5、串行化</strong></p><p>（1）打开一个客户端A，并设置当前事务模式为serializable，查询表account的初始值：</p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>set tx_isolation=&#39;serializable&#39;;              \n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>​ <img src="https://img.jssjqd.cn/202307041846193.png" alt="image-20230704184641116" loading="lazy"></p><p>（2）打开一个客户端B，并设置当前事务模式为serializable，更新相同的id为1的记录会被阻塞等待，更新id为2的记录可以成功，说明在串行模式下innodb的查询也会被加上行锁，如果查询的记录不存在会给这条不存在的记录加上锁(这种是间隙锁，后面会详细讲)。</p><p>如果客户端A执行的是一个范围查询，那么该<strong>范围内的所有行包括每行记录所在的间隙区间范围都会被加锁</strong>。此时如果客户端B在该范围内插入数据都会被阻塞，所以就避免了幻读。</p><p>这种隔离级别并发性极低，开发中很少会用。</p><p>​ <img src="https://img.jssjqd.cn/202307041846674.png" alt="image-20230704184637684" loading="lazy"></p><p><strong>事务问题定位</strong></p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code>#查询执行时间超过1秒的事务，详细的定位问题方法后面讲完锁课程后会一起讲解 \n\nSELECT *  FROM information_schema.innodb_trx  WHERE TIME_TO_SEC( timediff( now( ), trx_started ) ) &gt; 1;  \n\n#强制结束事务 kill 事务对应的线程id(就是上面语句查出结果里的trx_mysql_thread_id字段的值)         \n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>大事务的影响</strong></p><ul><li>并发情况下，数据库连接池容易被撑爆</li><li>锁定太多的数据，造成大量的阻塞和锁超时</li><li>执行时间长，容易造成主从延迟</li><li>回滚所需要的时间比较长</li><li>undo log膨胀</li><li>容易导致死锁</li></ul><p><strong>事务优化</strong></p><ul><li>将查询等数据准备操作放到事务外</li><li>事务中避免远程调用，远程调用要设置超时，防止事务等待时间太久</li><li>事务中避免一次性处理太多数据，可以拆分成多个事务分次处理</li><li>更新等涉及加锁的操作尽可能放在事务靠后的位置</li><li>能异步处理的尽量异步处理</li><li>应用侧(业务代码)保证数据一致性，非事务执行</li></ul><h2 id="常见问题" tabindex="-1"><a class="header-anchor" href="#常见问题" aria-hidden="true">#</a> 常见问题</h2><h3 id="查询操作方法需要使用事务吗" tabindex="-1"><a class="header-anchor" href="#查询操作方法需要使用事务吗" aria-hidden="true">#</a> 查询操作方法需要使用事务吗</h3><p>当数据库隔离级别是可重复读时，查询方法分两种情况：</p><p>1.方法里面只有一条查询语句，不需要开启事务。</p><p>2.方法里面有多条查询语句，需要根据业务情况判断是否需要开启事务。</p><p>比如一个报表方法里有多个查询语句，如果需要每条查询语句查询到的数据都和第一条查询语句处于同一个时刻，那就需要开启事务。</p><p>当数据库隔离级别是读已提交时:</p><p>无论是否加事务，多个查询语句都能够 查到其他事务已提交的数据。</p>',92),l=[s];function d(p,r){return e(),i("div",null,l)}const o=a(n,[["render",d],["__file","06.MySQL事务原理与优化最佳实践.html.vue"]]);export{o as default};
