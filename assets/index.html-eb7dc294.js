const e=JSON.parse('{"key":"v-688ba9a9","path":"/pages/6ead1a/","title":"并发工具之Atomic原子操作类详解","lang":"zh-CN","frontmatter":{"title":"并发工具之Atomic原子操作类详解","date":"2022-11-21T13:38:22.000Z","permalink":"/pages/6ead1a/","author":{"name":"江"},"category":["并发编程"],"description":"Atomic原子操作类介绍 在并发编程中很容易出现并发安全的问题，有一个很简单的例子就是多线程更新变量i=1,比如多个线程执行i++操作，就有可能获取不到正确的值，而这个问题，最常用的方法是通过Synchronized进行控制来达到线程安全的目的。但是由于synchronized是采用的是悲观锁策略，并不是特别高效的一种解决方案。实际上，在J.U.C下的atomic包提供了一系列的操作简单，性能高效，并能保证线程安全的类去更新基本类型变量，数组元素，引用类型以及更新对象中的字段类型。atomic包下的这些类都是采用的是乐观锁策略去原子更新数据，在java中则是使用CAS操作具体实现。","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/pages/6ead1a/"}],["meta",{"property":"og:site_name","content":"学习笔记"}],["meta",{"property":"og:title","content":"并发工具之Atomic原子操作类详解"}],["meta",{"property":"og:description","content":"Atomic原子操作类介绍 在并发编程中很容易出现并发安全的问题，有一个很简单的例子就是多线程更新变量i=1,比如多个线程执行i++操作，就有可能获取不到正确的值，而这个问题，最常用的方法是通过Synchronized进行控制来达到线程安全的目的。但是由于synchronized是采用的是悲观锁策略，并不是特别高效的一种解决方案。实际上，在J.U.C下的atomic包提供了一系列的操作简单，性能高效，并能保证线程安全的类去更新基本类型变量，数组元素，引用类型以及更新对象中的字段类型。atomic包下的这些类都是采用的是乐观锁策略去原子更新数据，在java中则是使用CAS操作具体实现。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-08-01T18:24:48.000Z"}],["meta",{"property":"article:author","content":"江"}],["meta",{"property":"article:published_time","content":"2022-11-21T13:38:22.000Z"}],["meta",{"property":"article:modified_time","content":"2023-08-01T18:24:48.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"并发工具之Atomic原子操作类详解\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2022-11-21T13:38:22.000Z\\",\\"dateModified\\":\\"2023-08-01T18:24:48.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"江\\"}]}"]]},"headers":[{"level":2,"title":"Atomic原子操作类介绍","slug":"atomic原子操作类介绍","link":"#atomic原子操作类介绍","children":[{"level":3,"title":"原子更新基本类型","slug":"原子更新基本类型","link":"#原子更新基本类型","children":[]},{"level":3,"title":"原子更新数组类型","slug":"原子更新数组类型","link":"#原子更新数组类型","children":[]},{"level":3,"title":"原子更新引用类型","slug":"原子更新引用类型","link":"#原子更新引用类型","children":[]},{"level":3,"title":"对象属性原子修改","slug":"对象属性原子修改","link":"#对象属性原子修改","children":[]}]}],"git":{"createdTime":1690914288000,"updatedTime":1690914288000,"contributors":[{"name":"jiangqingdong","email":"thejqd@gmail.com","commits":1}]},"readingTime":{"minutes":9.5,"words":2851},"filePathRelative":"10.并发编程/41.并发工具之Atomic原子操作类详解.md","localizedDate":"2022年11月21日","excerpt":"<h2> Atomic原子操作类介绍</h2>\\n<p>在并发编程中很容易出现并发安全的问题，有一个很简单的例子就是多线程更新变量i=1,比如多个线程执行i++操作，就有可能获取不到正确的值，而这个问题，最常用的方法是通过Synchronized进行控制来达到线程安全的目的。但是由于synchronized是采用的是悲观锁策略，并不是特别高效的一种解决方案。实际上，在J.U.C下的atomic包提供了一系列的操作简单，性能高效，并能保证线程安全的类去更新基本类型变量，数组元素，引用类型以及更新对象中的字段类型。atomic包下的这些类都是采用的是乐观锁策略去原子更新数据，在java中则是使用CAS操作具体实现。</p>","autoDesc":true}');export{e as data};
